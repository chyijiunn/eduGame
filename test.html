<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>紅巨星救援計畫：Solar Rescue</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    color: #fff;
  }
  #ui {
    position: fixed;
    left: 0; right: 0; top: 0;
    display: flex;
    gap: 10px;
    padding: 8px 12px;
    align-items: center;
    background: linear-gradient(180deg, rgba(0,0,0,.7), rgba(0,0,0,.25));
    backdrop-filter: blur(2px);
    z-index: 3;
    font-size: 14px;
  }
  #ui .pill { padding: 4px 8px; border-radius: 999px; background: rgba(255,255,255,.08); }
  #buttons { margin-left: auto; display: flex; gap: 8px; }
  button {
    background: rgba(255,255,255,.12);
    color: #fff; border: 0; border-radius: 8px;
    padding: 6px 10px; font-size: 14px;
  }
  button:hover { background: rgba(255,255,255,.18); cursor: pointer; }
  #msg {
    position: fixed; left: 50%; top: 60px; transform: translateX(-50%);
    padding: 8px 12px; border-radius: 8px; background: rgba(0,0,0,.6); z-index: 3;
    pointer-events: none; opacity: 0; transition: opacity .2s ease;
    white-space: pre-line;
  }
  #overlay {
    position: fixed; inset: 0; z-index: 4; display: none; place-items: center;
    background: rgba(0,0,0,.6);
  }
  #overlay .panel {
    max-width: min(720px, 92vw);
    background: rgba(15,15,20,.95);
    border: 1px solid rgba(255,255,255,.1);
    border-radius: 16px; padding: 18px 18px 14px;
    box-shadow: 0 10px 30px rgba(0,0,0,.5);
  }
  #overlay h2 { margin: 0 0 8px; }
  #overlay p, #overlay li { line-height: 1.5; color: #ddd; }
  #sunbar {
    position: fixed; left: 0; right: 0; bottom: 0;
    height: 8px; z-index: 2; background: rgba(255,255,255,.08);
  }
  #sunfill { height: 100%; width: 0; background: linear-gradient(90deg, #ffcf33, #ff3b3b); }
  canvas { display: block; width: 100vw; height: 100vh; }
  /* 小提示角標 */
  #hint {
    position: fixed; right: 12px; bottom: 16px; z-index: 3;
    background: rgba(0,0,0,.45); padding: 6px 10px; border-radius: 8px; font-size: 12px;
    opacity: .9;
  }
</style>
</head>
<body>
<div id="ui">
  <div class="pill">關卡：<span id="levelName">—</span></div>
  <div class="pill">剩餘生物：<span id="leftCount">—</span></div>
  <div class="pill">已救援 🧍：<span id="rescued">0</span></div>
  <div class="pill">死亡 💀：<span id="dead">0</span></div>
  <div id="buttons">
    <button id="helpBtn">說明</button>
    <button id="retryBtn">重玩關卡</button>
    <button id="nextBtn" disabled>下一關 ▶</button>
  </div>
</div>
<div id="msg"></div>
<div id="overlay">
  <div class="panel">
    <h2>玩法說明</h2>
    <ul>
      <li>太陽將爆成紅巨星，你是救援隊，要依序在八大行星上拯救小生物。</li>
      <li><b>第一下觸控/點擊是錨點</b>，<b>拖曳距離=力道</b>，<b>放開=發射太空梭</b>。</li>
      <li>太空梭受行星重力影響。若從<b>切線方向</b>進入可<b>形成環繞軌道</b>。</li>
      <li>在<b>穩定繞行</b>狀態下經過中央生物即可<b>安全收容</b>；非繞行狀態硬撞會造成<b>死亡</b>。</li>
      <li>本關所有生物被救走就能前進下一關；若全滅則<b>遊戲結束</b>（可重試）。</li>
    </ul>
    <p style="opacity:.8">提示：拖曳方向就是初速方向；靠近切線、速度適中較易入軌。</p>
    <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end">
      <button id="closeHelp">開始救援 🚀</button>
    </div>
  </div>
</div>
<div id="sunbar"><div id="sunfill"></div></div>
<canvas id="game"></canvas>
<div id="hint">第一下為錨點 → 拖曳 → 放開發射</div>

<script>
/* ========= 資料定義 ========= */
const PLANETS = [
  // name, grav(m/s^2), visualRadius(px base), color, creatures, ring?
  {name:"水星", g:3.7,  r:90,  color:"#7a8aa0", creatures:5},
  {name:"金星", g:8.87, r:120, color:"#d8b45b", creatures:6},
  {name:"地球", g:9.81, r:130, color:"#5fb9e5", creatures:7},
  {name:"火星", g:3.71, r:110, color:"#b3533a", creatures:7},
  {name:"木星", g:24.79,r:180, color:"#d89a6a", creatures:10},
  {name:"土星", g:10.44,r:165, color:"#cdbb89", creatures:9, ring:true},
  {name:"天王星",g:8.69, r:140, color:"#7fd0c4", creatures:8},
  {name:"海王星",g:11.15,r:145, color:"#355edb", creatures:8}
];
// 視覺縮放：行星引力 → 模擬常數（越大重力越強）
const G_CONST = 1000; // 調整引力強度
const AIR_DRAG = 0.000; // 金星等可做特例拖曳
/* ========= 畫布初始化 ========= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });
function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

/* ========= UI 元素 ========= */
const levelName = document.getElementById('levelName');
const leftCount = document.getElementById('leftCount');
const rescuedEl = document.getElementById('rescued');
const deadEl = document.getElementById('dead');
const nextBtn = document.getElementById('nextBtn');
const retryBtn = document.getElementById('retryBtn');
const helpBtn = document.getElementById('helpBtn');
const overlay = document.getElementById('overlay');
const closeHelp = document.getElementById('closeHelp');
const sunfill = document.getElementById('sunfill');
const msgEl = document.getElementById('msg');

function showMsg(t, ms=1200){
  msgEl.textContent = t;
  msgEl.style.opacity = 1;
  clearTimeout(showMsg._t);
  showMsg._t = setTimeout(()=> msgEl.style.opacity = 0, ms);
}
helpBtn.onclick = ()=> overlay.style.display = 'grid';
closeHelp.onclick = ()=> overlay.style.display = 'none';

/* ========= 遊戲狀態 ========= */
let level = 0;
let rescuedTotal = 0;
let deadTotal = 0;

let planet = null;
let creatures = []; // 生物陣列
let ship = null;    // 單一飛行器
let trail = [];     // 航跡
let inOrbitTimer = 0;
let orbitStable = false;
let sunProgress = 0; // 0~1 紅巨星進度

// 拖曳手勢
let dragging = false;
let anchor = null;
let pointer = null;

// 背景太陽
function bgSunGradient(progress){
  // 由黃白 → 橘紅
  const r = Math.floor(255*(0.6+0.4*progress));
  const g = Math.floor(200*(1-progress));
  const b = Math.floor(60*(1-progress));
  return `radial-gradient(circle at 15% 20%, rgba(${r},${g},${b},0.45), rgba(0,0,0,0.9) 55%)`;
}

/* ========= 實體：生物與太空梭 ========= */
function spawnCreatures(n){
  creatures = [];
  for(let i=0;i<n;i++){
    // 生物在「行星中心附近」的小範圍跳動（視覺=剪影）
    creatures.push({
      alive:true,
      // 讓他們在星球中心附近半徑的 0.35R 以內微動
      baseR: planet.r * 0.35 * (0.6 + Math.random()*0.8),
      angle: Math.random()*Math.PI*2,
      jitter: Math.random()*0.6 + 0.4, // 動幅
    });
  }
}

function spawnShip(pos){
  ship = {
    x: pos.x, y: pos.y,
    vx: 0, vy: 0,
    alive: true,
    carrying: false, // 是否載到生物
    t: 0
  };
  trail = [];
  orbitStable = false; inOrbitTimer = 0;
}

function planetCenter(){
  return { x: canvas.width*0.5, y: canvas.height*0.55 };
}

/* ========= 關卡控制 ========= */
function loadLevel(i){
  level = i;
  planet = structuredClone(PLANETS[level]);
  // 金星空氣阻力（小幅）
  planet.drag = (planet.name==="金星") ? 0.0006 : 0.00015;
  // 天王星/海王星讓空間更「滑」
  if (planet.name==="天王星" || planet.name==="海王星") planet.drag *= 0.6;

  levelName.textContent = `${level+1}/8 ${planet.name}`;
  spawnCreatures(planet.creatures);
  leftCount.textContent = creatures.filter(c=>c.alive).length;
  nextBtn.disabled = true;
  ship = null;
  trail = [];
  inOrbitTimer = 0; orbitStable = false;
  // 更新太陽進度條
  sunProgress = (level)/ (PLANETS.length);
  sunfill.style.width = `${Math.floor(100*sunProgress)}%`;
  document.body.style.background = bgSunGradient(sunProgress);
  showMsg(`第 ${level+1} 關：${planet.name}`);
}

function winLevel(){
  nextBtn.disabled = false;
  showMsg(`✅ 本關完成！可前往下一關`);
}
function gameOver(){
  showMsg(`❌ 生物全滅，任務失敗（可重試）`, 1600);
}

/* ========= 輸入事件（滑鼠 + 觸控） ========= */
function getPointFromEvent(e){
  if (e.touches && e.touches.length) {
    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
  return { x: e.clientX, y: e.clientY };
}

canvas.addEventListener('pointerdown', e=>{
  dragging = true;
  anchor = getPointFromEvent(e);
  pointer = anchor;
});
canvas.addEventListener('pointermove', e=>{
  if (!dragging) return;
  pointer = getPointFromEvent(e);
});
window.addEventListener('pointerup', e=>{
  if (!dragging) return;
  dragging = false;
  // 發射：起點=錨點，速度=錨點→放開向量 * 比例
  const release = getPointFromEvent(e);
  const dx = release.x - anchor.x;
  const dy = release.y - anchor.y;
  const speedScale = 0.035; // 調整手感（越大越快）
  spawnShip(anchor);
  ship.vx = dx * speedScale;
  ship.vy = dy * speedScale;
});

/* ========= 物理更新 ========= */
function step(dt){
  const c = planetCenter();

  // 生物抖動
  const t = performance.now()/1000;
  for(const b of creatures){
    if(!b.alive) continue;
    b.angle += 0.4*dt;
  }

  // 飛船物理
  if (ship && ship.alive){
    ship.t += dt;
    const rx = c.x - ship.x;
    const ry = c.y - ship.y;
    const r2 = rx*rx + ry*ry;
    const r = Math.sqrt(r2);

    // 碰撞判定（撞到行星表面）
    if (r < planet.r*0.95){
      // 依速度規模決定死亡數
      const vmag = Math.hypot(ship.vx, ship.vy);
      const kill = Math.min(
        creatures.filter(b=>b.alive).length,
        Math.max(1, Math.floor(vmag/120)+ (planet.g>10?1:0))
      );
      // 殺死 kill 隻
      let leftToKill = kill;
      for (const b of creatures){
        if (b.alive && leftToKill>0){ b.alive=false; leftToKill--; }
      }
      deadTotal += kill;
      deadEl.textContent = deadTotal;
      leftCount.textContent = creatures.filter(b=>b.alive).length;
      showMsg(`💥 墜毀！死亡 ${kill}`);
      ship.alive = false;
      checkLevelState();
      return;
    }

    // 引力（簡化萬有引力）
    // a = G * gPlanet / r^2 方向指向中心（這裡把行星 g 當作質量尺度）
    const g = (G_CONST * planet.g) / (r2 + 2000); // 防止 r=0 爆炸
    const ax = g * (rx / r);
    const ay = g * (ry / r);

    // 阻力（簡單速度成比例）
    const dvx = ship.vx * planet.drag;
    const dvy = ship.vy * planet.drag;

    ship.vx += (ax - dvx) * dt;
    ship.vy += (ay - dvy) * dt;

    ship.x += ship.vx * dt;
    ship.y += ship.vy * dt;

    // 航跡
    trail.push({x:ship.x, y:ship.y});
    if (trail.length>180) trail.shift();

    // 軌道穩定性檢測：近切線 & 半徑變化小 一段時間
    // 條件1：速度方向與半徑向量夾角 ~90°（點積接近0）
    const vmag = Math.hypot(ship.vx, ship.vy);
    const dot = (ship.vx * rx + ship.vy * ry) / (vmag * r + 1e-6);
    const nearTangent = Math.abs(dot) < 0.17; // 夾角 ~80~100 度
    // 條件2：半徑接近某定值（在合理軌道高度）
    const nearRing = r > planet.r*1.02 && r < planet.r*1.8;

    if (nearTangent && nearRing) {
      inOrbitTimer += dt;
      if (inOrbitTimer > 1.2) orbitStable = true;
    } else {
      inOrbitTimer = Math.max(0, inOrbitTimer - dt*0.8);
      if (inOrbitTimer < 0.3) orbitStable = false;
    }

    // 準備救援：只有在穩定繞行時，飛越中心附近才算成功收容
    if (orbitStable && !ship.carrying){
      // 檢查最近的一隻活著的生物：它們都在中心附近半徑~0.35R 範圍
      // 用「經過中心半徑 0.45R」視作能安全交會
      if (r < planet.r*0.45){
        // 收走一隻
        const target = creatures.find(b=>b.alive);
        if (target){
          target.alive = false;
          ship.carrying = true;
          rescuedTotal += 1;
          rescuedEl.textContent = rescuedTotal;
          leftCount.textContent = creatures.filter(b=>b.alive).length;
          showMsg(`🧍 救到 1 隻！`);
        }
      }
    }

    // 載到生物後自動「返回」：沿半徑外逃
    if (ship.carrying){
      // 給一個朝外的推進（一次性）
      const nx = (ship.x - c.x)/ (r+1e-6);
      const ny = (ship.y - c.y)/ (r+1e-6);
      ship.vx += nx * 8*planet.drag; // 小推力
      ship.vy += ny * 8*planet.drag;
      // 抵達畫面外算完成這次出擊
      if (ship.x < -80 || ship.x > canvas.width+80 || ship.y < -80 || ship.y > canvas.height+80){
        ship.alive = false;
        checkLevelState();
      }
    }

    // 飛出很遠就當作失敗（超出任務區域）
    if (!ship.carrying && (ship.x < -200 || ship.x > canvas.width+200 || ship.y < -200 || ship.y > canvas.height+200)){
      ship.alive = false;
      showMsg(`❎ 偏航，請再試一次`);
      checkLevelState();
    }
  }
}

function checkLevelState(){
  const alive = creatures.filter(b=>b.alive).length;
  if (alive === 0){
    // 若該關至少救到 1 隻 → 過關；否則 Game Over
    // 判斷這關救援數：看本關總數 - 死亡於本關 - 剩餘(=0)
    // 但簡化：若剛剛有任何 rescue 事件，rescuedTotal 在本關中至少 +1
    if (currentLevelRescued() > 0){
      winLevel();
    } else {
      gameOver();
    }
  }
}

function currentLevelRescued(){
  // 估算：全域 rescuedTotal 減去之前關卡的累計
  // 為了簡單，進關時記錄起始值
  return rescuedTotal - (loadLevel._rescuedAtStart ?? 0);
}

/* ========= 繪製 ========= */
function draw(){
  const w = canvas.width, h = canvas.height;
  const c = planetCenter();

  // 背景星空與太陽暈
  const grd = ctx.createRadialGradient(w*0.15, h*0.2, 30, w*0.15, h*0.2, Math.max(w,h)*0.9);
  const sunColor = `rgba(${200+Math.floor(55*sunProgress)}, ${150-Math.floor(90*sunProgress)}, ${40}, 0.5)`;
  grd.addColorStop(0, sunColor);
  grd.addColorStop(1, "#000000");
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,w,h);

  // 行星本體
  // 漸層 + 邊緣陰影
  const pgr = ctx.createRadialGradient(c.x - planet.r*0.4, c.y - planet.r*0.4, planet.r*0.2, c.x, c.y, planet.r*1.2);
  pgr.addColorStop(0, lighten(planet.color, 0.25));
  pgr.addColorStop(0.7, planet.color);
  pgr.addColorStop(1, shade(planet.color, 0.65));
  ctx.fillStyle = pgr;
  ctx.beginPath();
  ctx.arc(c.x, c.y, planet.r, 0, Math.PI*2);
  ctx.fill();

  // 土星光環
  if (planet.ring){
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.rotate(-0.35);
    ctx.strokeStyle = "rgba(230,210,160,0.65)";
    ctx.lineWidth = 12;
    ctx.beginPath();
    ctx.ellipse(0,0, planet.r*1.55, planet.r*0.75, 0, 0, Math.PI*2);
    ctx.stroke();
    ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(230,210,160,0.3)";
    ctx.beginPath();
    ctx.ellipse(0,0, planet.r*1.35, planet.r*0.66, 0, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  // 生物（剪影，中心附近抖動）
  for(const b of creatures){
    if(!b.alive) continue;
    const x = c.x + Math.cos(b.angle)*b.baseR*0.6;
    const y = c.y + Math.sin(b.angle*1.2)*b.baseR*0.4;
    drawCreature(x, y, 10);
  }

  // 航跡
  if (trail.length>1){
    ctx.strokeStyle = orbitStable ? "rgba(100,255,180,.9)" : "rgba(255,255,255,.6)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i=0;i<trail.length;i++){
      const p = trail[i];
      if (i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
  }

  // 飛船
  if (ship && ship.alive){
    drawShip(ship.x, ship.y, ship.vx, ship.vy, ship.carrying);
  }

  // 拖曳向量（發射預覽）
  if (dragging && anchor && pointer){
    ctx.strokeStyle = "rgba(255,255,255,.85)";
    ctx.fillStyle = "rgba(255,255,255,.15)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(anchor.x, anchor.y);
    ctx.lineTo(pointer.x, pointer.y);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(anchor.x, anchor.y, 6, 0, Math.PI*2);
    ctx.fill();
  }

  // 輔助：軌道帶（提示繞行高度）
  ctx.strokeStyle = "rgba(255,255,255,.08)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(c.x, c.y, planet.r*1.4, 0, Math.PI*2);
  ctx.stroke();
}

function drawCreature(x,y,s){
  // 小水滴 + 觸角的剪影
  ctx.save();
  ctx.translate(x,y);
  ctx.fillStyle = "#000";
  ctx.shadowColor = "rgba(0,0,0,.3)";
  ctx.shadowBlur = 6;
  ctx.beginPath();
  ctx.moveTo(0,-s*0.9);
  ctx.quadraticCurveTo(s*0.9, -s*0.1, 0, s);
  ctx.quadraticCurveTo(-s*0.9, -s*0.1, 0, -s*0.9);
  ctx.fill();
  // 兩根小角
  ctx.strokeStyle = "#000";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-s*0.2, -s*0.7);
  ctx.quadraticCurveTo(-s*0.6, -s*1.1, -s*0.4, -s*1.2);
  ctx.moveTo(s*0.2, -s*0.7);
  ctx.quadraticCurveTo(s*0.6, -s*1.1, s*0.4, -s*1.2);
  ctx.stroke();
  ctx.restore();
}

function drawShip(x,y,vx,vy, carrying){
  const ang = Math.atan2(vy, vx);
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(ang);
  // 機身
  ctx.fillStyle = carrying ? "#7bffc9" : "#ffffff";
  ctx.beginPath();
  ctx.moveTo(14,0);
  ctx.lineTo(-10,-6);
  ctx.lineTo(-6,0);
  ctx.lineTo(-10,6);
  ctx.closePath();
  ctx.fill();
  // 火焰
  ctx.fillStyle = carrying ? "rgba(100,255,200,.8)" : "rgba(255,160,80,.9)";
  ctx.beginPath();
  ctx.moveTo(-10,0);
  ctx.lineTo(-18,-3);
  ctx.lineTo(-16,0);
  ctx.lineTo(-18,3);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

/* ========= 顏色工具 ========= */
function hexToRgb(hex){
  const m = hex.replace('#','');
  const num = parseInt(m,16);
  if (m.length===6){
    return {r:(num>>16)&255, g:(num>>8)&255, b:num&255};
  }
  return {r:200,g:200,b:200};
}
function lighten(hex, k){
  const {r,g,b}=hexToRgb(hex); const L = c=>Math.min(255, Math.round(c + (255-c)*k));
  return `rgb(${L(r)},${L(g)},${L(b)})`;
}
function shade(hex, k){
  const {r,g,b}=hexToRgb(hex); const S = c=>Math.max(0, Math.round(c*(1-k)));
  return `rgb(${S(r)},${S(g)},${S(b)})`;
}

/* ========= 主迴圈 ========= */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.033, (now - last)/1000); // 限制最大步長
  last = now;
  step(dt);
  draw();
  requestAnimationFrame(loop);
}

/* ========= 控制按鈕 ========= */
retryBtn.onclick = ()=>{
  loadLevel(level);
  loadLevel._rescuedAtStart = rescuedTotal;
};
nextBtn.onclick = ()=>{
  if (level < PLANETS.length-1){
    loadLevel(level+1);
    loadLevel._rescuedAtStart = rescuedTotal;
  } else {
    showMsg("🎉 全部關卡完成！你帶著他們離開太陽系了");
  }
};

/* ========= 初始化 ========= */
(function init(){
  loadLevel._rescuedAtStart = 0;
  loadLevel(0);
  overlay.style.display = 'grid'; // 第一次顯示說明
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>