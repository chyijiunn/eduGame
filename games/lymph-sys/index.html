<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>æ·‹å·´å®ˆåŸï¼šå®Œæ•´æ•´åˆæœ€çµ‚ç‰ˆ</title>
<style>
  :root{--bg:#0b1020; --panel:#101935; --text:#eaf1ff; --acc:#7be3b0; --warn:#ffd166; --danger:#ff6b6b;}
  *{box-sizing:border-box; font-family: system-ui, -apple-system, "Noto Sans TC", "Segoe UI", Roboto, Arial;}
  body{margin:0; background:linear-gradient(180deg,#0b1020 0%, #0f1a3a 100%); color:var(--text);}
  header{display:flex;align-items:center;gap:.6rem; padding:.7rem 1rem; background:#0d1633; position:sticky; top:0; z-index:5; box-shadow:0 2px 8px rgba(0,0,0,.4)}
  .stat{padding:.35rem .6rem; border:1px solid #1f2b55; border-radius:10px; background:#0f1a3a; font-weight:700}
  header button{appearance:none;border:none;border-radius:10px; padding:.55rem .8rem; background:#1a3568; color:#d8e8ff; cursor:pointer}
  header button:hover{background:#23457f}
  #wrap{display:grid; grid-template-columns:1fr; justify-items:center; padding:10px}
  #gamebox{position:relative; width:min(1100px,96vw); aspect-ratio:16/9; background:#081224; border:1px solid #1a2a54; border-radius:16px; overflow:hidden; box-shadow:0 6px 24px rgba(0,0,0,.5)}
  canvas{width:100%; height:100%; display:block}
  #panel{display:flex;gap:.6rem;flex-wrap:wrap; padding:8px 0; justify-content:center}
  .tool{display:flex;align-items:center;gap:.4rem; padding:.5rem .7rem; border:1px solid #2a3c74; border-radius:10px; background:#0f1c3d; cursor:pointer; position:relative}
  .tool strong{letter-spacing:.5px}
  .tool .cost{opacity:.85}
  .selected{outline:2px solid var(--acc)}
  .cdbar{position:absolute; left:0; top:0; height:100%; width:0%; background:rgba(255,255,255,0.18); pointer-events:none; transition:width .1s linear}
  /* circular 5s countdown */
  #autocircle{position:absolute; right:80px; bottom:80px; width:88px; height:88px; display:none;}
  #autocircle svg{width:100%; height:100%; transform:rotate(-90deg)}
  #autocircle .bg{fill:none; stroke:rgba(255,255,255,0.25); stroke-width:8}
  #autocircle .prog{fill:none; stroke:rgba(255,255,255,0.85); stroke-width:8; stroke-linecap:round; stroke-dasharray:283; stroke-dashoffset:283}
  #autocircle .num{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:26px; font-weight:800; color:#fff; text-shadow:0 0 8px rgba(255,255,255,.6)}
  /* modal */
  #modal{position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:20}
  #modal .card{width:min(900px,94vw); max-height:min(90vh, 780px); background:#0f1a3a; border:1px solid #27407a; border-radius:14px; overflow:hidden; display:flex; flex-direction:column}
  #modal .card header{position:unset; box-shadow:none; background:#0f1a3a; display:flex; align-items:center; padding:10px}
  #modal .content{padding:12px 16px 18px; overflow:auto}
  #modal h2{margin:.2rem 0 .6rem 0}
  #modal h3{margin:1.1rem 0 .4rem 0; color:#cde7ff}
  #modal ul{margin:.2rem 0 .8rem 1.2rem}
  #modal li{margin:.2rem 0; line-height:1.5}
  #modal .close{margin-left:auto; appearance:none; border:none; border-radius:10px; padding:.4rem .7rem; background:#1a3568; color:#d8e8ff; cursor:pointer}
</style>
</head>
<body>
<header>
  <div class="stat">CPï¼š<span id="cp">250</span></div>
  <div class="stat">Waveï¼š<span id="wave">0</span>/<span id="wmax">12</span></div>
  <div class="stat">Livesï¼š<span id="lives">15</span></div>
  <button id="pause">ç¹¼çºŒ</button>
  <button id="help">æ•™å­¸</button>
</header>
<div id="wrap">
  <div id="gamebox">
    <canvas id="game" width="1152" height="648"></canvas>
    <div id="autocircle">
      <svg viewBox="0 0 100 100">
        <circle class="bg" cx="50" cy="50" r="45"></circle>
        <circle class="prog" cx="50" cy="50" r="45"></circle>
      </svg>
      <div class="num" id="autonum">5</div>
    </div>
  </div>
  <div id="panel">
    <div class="tool" data-type="COMPLEMENT"><span class="cdbar"></span><strong>è£œé«”ç³»çµ±</strong><span class="cost">CP 70</span><span>ï¼ˆè²¼æ¨™ï¼‹è¼•å‚·ï¼‰</span></div>
    <div class="tool" data-type="MACRO"><span class="cdbar"></span><strong>å·¨å™¬ç´°èƒ</strong><span class="cost">CP 80</span><span>ï¼ˆå–®é«”é«˜å‚·ï¼‰</span></div>
    <div class="tool" data-type="INFLAM"><span class="cdbar"></span><strong>ç™¼ç‚ä»‹è³ª</strong><span class="cost">CP 70</span><span>ï¼ˆç¯„åœæ¸›é€Ÿï¼‰</span></div>
    <div class="tool" data-type="ANTIBODY"><span class="cdbar"></span><strong>æŠ—é«”</strong><span class="cost">CP 90</span><span>ï¼ˆè¿½è¹¤å¼·æ“Šï¼‰</span></div>
    <div class="tool" id="up"><span class="cdbar"></span><strong>å‡ç´šï¼ˆç­‰å·®æˆæœ¬ï¼‰</strong><span class="cost">åŸºç¤ 60ï¼Œæ¯ç´š +20ï¼ˆLvâ‰¤5ï¼‰</span></div>
    <div class="tool" id="sell"><span class="cdbar"></span><strong>å‡ºå”®</strong><span class="cost">è¿”é‚„60%</span></div>
    <div class="tool" id="swell"><span class="cdbar" id="cd_swell"></span><strong>æ·‹å·´çµè…«å¤§</strong><span class="cost">CP 50</span><span>ï¼ˆç¹è·¯12s / å†·å»20sï¼‰</span></div>
    <div class="tool" id="chaser"><span class="cdbar" id="cd_chaser"></span><strong>è¿½æ“Šæ·‹å·´çƒï¼ˆILâ€‘2ï¼‰</strong><span class="cost">CP 60</span><span>ï¼ˆå£½å‘½10s / å†·å»15sï¼‰</span></div>
  </div>
</div>

<!-- Tutorial Modal -->
<div id="modal">
  <div class="card">
    <header>
      <div class="stat">ğŸ“˜ æ•™å­¸ / è¦å‰‡ç¸½è¦½</div>
      <button class="close">é—œé–‰</button>
    </header>
    <div class="content" id="tutorial">
      <h2>ç›®æ¨™èˆ‡æµç¨‹</h2>
      <ul>
        <li>å®ˆä½ 12 æ³¢æ”»æ“Šï¼ˆç¬¬ 4 / 8 / 12 æ³¢ç‚º Bossï¼‰ã€‚</li>
        <li>é–‹å ´<b>æš«åœ</b>ï¼›å…ˆä½ˆç½² â†’ æŒ‰<b>ç¹¼çºŒ</b>é–‹ç¬¬ 1 æ³¢ã€‚</li>
        <li>æ¸…å ´ï¼ˆå ´ä¸Šç„¡æ•µäººä¸”éšŠåˆ—ç‚ºç©ºï¼‰æ™‚ï¼Œå³ä¸‹å‡ºç¾ <b>5 ç§’</b> åœ“å½¢å€’æ•¸ â†’ è‡ªå‹•é€²ä¸‹ä¸€æ³¢ã€‚</li>
      </ul>
      <h3>ç”Ÿå‘½èˆ‡å¤±æ•—</h3>
      <ul>
        <li><b>åªæœ‰ç—…åŸé«”é€ƒå‡ºçµ‚é»æ‰ -1</b>ï¼›æ“Šæ®ºä¸æœƒæ‰£å‘½ã€‚</li>
        <li>Lives â‰¤ 0 ç«‹åˆ»å¤±æ•—ï¼›æ¸…é™¤ç¬¬ 12 æ³¢å³å‹åˆ©ã€‚</li>
      </ul>
      <h3>CPï¼ˆå…ç–«è³‡æºï¼‰</h3>
      <ul>
        <li>åˆå§‹ 250ï¼›æ“Šæ•—æ•µäººç²å¾— CPï¼ˆæ³¢æ•¸è¶Šé«˜å€ç‡è¶Šå¤§ï¼‰ã€‚</li>
        <li>å‡ºå”®è¿”é‚„ 60% æˆæœ¬ï¼›Boss æ‰è¼ƒå¤š CPã€‚</li>
      </ul>
      <h3>ç«™é»èˆ‡è·¯ç·š</h3>
      <ul>
        <li>åˆå§‹ 6 ç«™é»éš¨æ©Ÿæ•£è½ã€‚</li>
        <li>æ¯æ³¢å‰é‡ç¹ªè·¯ç·šï¼ˆç›´ï¼‹å½ï¼‰ï¼Œç¸½é•·ç´„ 1.45ï½1.6Ã— ç•«é¢å¯¬ï¼Œä¸”ä¸€å®š<b>ç¹éæ¯å€‹ç«™é»é™„è¿‘</b>ã€‚</li>
        <li>ç¬¬ 4 / 8 / 12 æ³¢å„æ–°å¢ 2 ç«™é»ã€‚</li>
      </ul>
      <h3>å¡”èˆ‡æŠ€èƒ½</h3>
      <ul>
        <li><b>è£œé«”</b>ï¼ˆCP 70ï¼‰ï¼šè²¼æ¨™ï¼‹è¼•å‚·ï¼›å·²è²¼æ¨™ç›®æ¨™æœƒè¢«å…¶ä»–å¡”åŠ æˆã€‚</li>
        <li><b>å·¨å™¬</b>ï¼ˆCP 80ï¼‰ï¼šå–®é«”é«˜å‚·ï¼›å°è²¼æ¨™ç›®æ¨™å‚·å®³åŠ æˆã€‚</li>
        <li><b>ç™¼ç‚ä»‹è³ª</b>ï¼ˆCP 70ï¼‰ï¼šç¯„åœç·©é€Ÿï¼‹å°å‚·ã€‚</li>
        <li><b>æŠ—é«”</b>ï¼ˆCP 90ï¼‰ï¼šè¿½è¹¤å½ˆï¼›å‘½ä¸­é«˜ä½†å°„é€Ÿè¼ƒæ…¢ï¼Œå°è²¼æ¨™åŠ æˆã€‚</li>
        <li><b>å‡ç´šï¼ˆç­‰å·®ï¼‰</b>ï¼šåŸºç¤ 60ï¼Œæ¯ç´š +20ï¼Œè‡³ Lv.5ã€‚</li>
        <li><b>æ·‹å·´çµè…«å¤§</b>ï¼ˆCP 50ï¼‰ï¼šé™„è¿‘ 12s ç”Ÿæˆè¿´ç¹è·¯æ®µï¼›å†·å» 20sï¼ˆæŒ‰éˆ•åŠé€æ˜æ¢é¡¯ç¤ºï¼‰ã€‚</li>
        <li><b>è¿½æ“Šæ·‹å·´çƒï¼ˆILâ€‘2ï¼‰</b>ï¼ˆCP 60ï¼‰ï¼šè‡ªå‹•è¿½è¹¤æ”»æ“Šï¼Œå£½å‘½ 10sï¼›å†·å» 15sï¼ˆåŒæ¨£ä»¥æ¢é¡¯ç¤ºï¼‰ã€‚</li>
      </ul>
      <h3>æ“ä½œ</h3>
      <ul>
        <li>é»ç«™é»æ”¾å¡”ï¼›å†é»é¸å¡”å¯å‡ç´š / å‡ºå”®ã€‚</li>
        <li><b>Space</b>ï¼šæš«åœ / ç¹¼çºŒï¼›<b>Esc</b> é—œé–‰æ•™å­¸ã€‚</li>
      </ul>
    </div>
  </div>
</div>

<script>
(()=>{
  function $(id){return document.getElementById(id);}
  const W=1152,H=648;
  const cnv=$('game'); const ctx=cnv.getContext('2d');
  const ui={cp:$('cp'), wave:$('wave'), wmax:$('wmax'), lives:$('lives')};
  const btn={pause:$('pause'), help:$('help')};
  const modal=$('modal'); const modalClose=modal.querySelector('.close');
  const autoBox=$('autocircle'); const autoNum=$('autonum'); const autoProg=autoBox.querySelector('.prog');
  const cdSwell=$('cd_swell'), cdChaser=$('cd_chaser');
  let placing=null, selected=null, paused=true;
  let autoTimer=5, autoActive=false;

  const UPGRADE_BASE=60, UPGRADE_STEP=20, MAX_LVL=5;

  const state={
    cp:250, lives:15, wave:0, wmax:12, time:0, gameOver:false, victory:false,
    basePath:[], enemies:[], towers:[], projs:[], crumb:[], queue:[],
    nodes:[], chasers:[],
    ability:{ swellCdDur:20, swellCdUntil:0, chaserCdDur:15, chaserCdUntil:0 },
    unlockedTypes:['virus','bacteria'],
  };
  ui.cp.textContent=state.cp; ui.wave.textContent=state.wave; ui.lives.textContent=state.lives; ui.wmax.textContent=state.wmax;

  // æ•™å­¸é–‹é—œ
  btn.help.addEventListener('click', ()=>{ modal.style.display='flex'; });
  modalClose.addEventListener('click', ()=>{ modal.style.display='none'; });
  modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') modal.style.display='none'; });

  // å¹¾ä½•å·¥å…·
  function dist(a,b){return Math.hypot(a.x-b.x, a.y-b.y);}
  function segDist(p,a,b){
    const AP={x:p.x-a.x,y:p.y-a.y}, AB={x:b.x-a.x,y:b.y-a.y};
    const ab2=AB.x*AB.x+AB.y*AB.y; if(!ab2) return Math.hypot(p.x-a.x,p.y-a.y);
    let t=(AP.x*AB.x+AP.y*AB.y)/ab2; t=Math.max(0,Math.min(1,t));
    const C={x:a.x+AB.x*t,y:a.y+AB.y*t};
    return Math.hypot(p.x-C.x,p.y-C.y);
  }
  function tooCloseToExisting(p, pts, minD, ignoreLastN=8){
    const L=pts.length;
    for(let i=1;i<L;i++){
      if(L-i <= ignoreLastN) continue;
      if(segDist(p, pts[i-1], pts[i]) < minD) return true;
    }
    return false;
  }
  function nearestPathIdx(node, path){
    let best=0, bestD=1e9;
    for(let i=0;i<path.length;i++){
      const dx=node.x-path[i].x, dy=node.y-path[i].y;
      const d=dx*dx+dy*dy;
      if(d<bestD){ bestD=d; best=i; }
    }
    return Math.max(1, Math.min(path.length-2, best));
  }

  // ç«™é»
  function scatterRandomNodes(count){
    const nodes=[];
    const margin=50, minDist=110;
    let guard=0;
    while(nodes.length<count && guard<2000){
      guard++;
      const x = margin + Math.random()*(W-2*margin);
      const y = margin + Math.random()*(H-2*margin);
      let ok=true;
      for(const n of nodes){
        if(Math.hypot(n.x-x, n.y-y) < minDist){ ok=false; break; }
      }
      if(ok) nodes.push({id:nodes.length, x, y, r:24, tower:null, gate:{startIdx:0, loop:null, activeUntil:0, cdUntil:0}});
    }
    return nodes;
  }
  state.nodes = scatterRandomNodes(6);

  // è·¯ç·šï¼ˆ1.45ï½1.6 Wï¼‰
  function generateMixedPath(){
    const margin=30, visitR=24, minSegGap=22;
    const pts=[];
    const sorted=[...state.nodes].sort((a,b)=>a.x-b.x);
    pts.push({x:margin, y:H*0.5});
    for(let i=0;i<sorted.length;i++){
      const n=sorted[i];
      let ax = Math.max(margin, Math.min(W-margin, n.x - (50+Math.random()*40)));
      let ay = Math.max(margin, Math.min(H-margin, (pts[pts.length-1].y*0.65 + n.y*0.35) + (Math.random()*30-15)));
      let ptA={x:ax,y:ay};
      let guard=0; while(tooCloseToExisting(ptA, pts, minSegGap) && guard<8){ ay += (Math.random()<0.5?-1:1)*10; ptA={x:ax,y:Math.max(margin,Math.min(H-margin,ay))}; guard++; }
      pts.push(ptA);
      const arcSteps= 5 + Math.floor(Math.random()*3);
      const rad = visitR + 4 + Math.random()*8;
      const cw = Math.random()<0.5? -1: 1;
      const baseA = Math.random()*Math.PI*2;
      const span = Math.PI*(0.6 + Math.random()*0.9);
      for(let s=0;s<=arcSteps;s++){
        const a = baseA + cw * span * (s/arcSteps);
        const p={x:n.x + Math.cos(a)*rad, y:n.y + Math.sin(a)*rad};
        if(tooCloseToExisting(p, pts, minSegGap)) { p.y += (Math.random()<0.5?-1:1)*12; }
        p.x=Math.max(margin,Math.min(W-margin,p.x));
        p.y=Math.max(margin,Math.min(H-margin,p.y));
        pts.push(p);
      }
      let bx = Math.max(margin, Math.min(W-margin, n.x + (55+Math.random()*45)));
      let by = Math.max(margin, Math.min(H-margin, n.y + (Math.random()*34-17)));
      let ptB={x:bx,y:by};
      guard=0; while(tooCloseToExisting(ptB, pts, minSegGap) && guard<8){ by += (Math.random()<0.5?-1:1)*10; ptB={x:bx,y:Math.max(margin,Math.min(H-margin,by))}; guard++; }
      pts.push(ptB);
      if(i<sorted.length-1){
        if(Math.random()<0.6){
          const nxt=sorted[i+1];
          const mx=(n.x+nxt.x)/2, my=((n.y+nxt.y)/2) + (Math.random()*20-10);
          const q={x:mx, y:Math.max(margin,Math.min(H-margin,my))};
          if(!tooCloseToExisting(q, pts, minSegGap)) pts.push(q);
        }else{
          const nxt=sorted[i+1];
          const mx=(n.x*0.7+nxt.x*0.3);
          const my=(n.y*0.7+nxt.y*0.3) + (Math.random()*24-12);
          const q1={x:mx, y:Math.max(margin,Math.min(H-margin,my))};
          if(!tooCloseToExisting(q1, pts, minSegGap)) pts.push(q1);
          const mx2=(n.x*0.3+nxt.x*0.7);
          const my2=(n.y*0.3+nxt.y*0.7) + (Math.random()*24-12);
          const q2={x:mx2, y:Math.max(margin,Math.min(H-margin,my2))};
          if(!tooCloseToExisting(q2, pts, minSegGap)) pts.push(q2);
        }
      }
    }
    pts.push({x:W-margin, y:H*0.5});
    function pathLength(ps){ let L=0; for(let i=1;i<ps.length;i++) L+=Math.hypot(ps[i].x-ps[i-1].x, ps[i].y-ps[i-1].y); return L; }
    let L=pathLength(pts);
    const targetMin=W*1.45, targetMax=W*1.6;
    let guard=0;
    while(L<targetMin && guard<6){
      guard++;
      const idx=2+Math.floor(Math.random()*(pts.length-4));
      let p={x:(pts[idx-1].x+pts[idx].x)/2 + (Math.random()*40-20),
             y:(pts[idx-1].y+pts[idx].y)/2 + (Math.random()*40-20)};
      if(!tooCloseToExisting(p, pts, 22)){
        pts.splice(idx,0,p);
        L=pathLength(pts);
      }
    }
    guard=0;
    while(L>targetMax && pts.length>30 && guard<6){
      guard++;
      const drop=3+Math.floor(Math.random()*(pts.length-6));
      pts.splice(drop,1);
      L=pathLength(pts);
    }
    return pts;
  }
  function makeVariedDetour(path, startIdx){
    const style = Math.random();
    const anchor = path[startIdx];
    const pts=[{x:anchor.x,y:anchor.y}];
    if(style<0.4){
      const radius = 60 + Math.random()*16;
      const span = Math.PI*(1.0 + Math.random()*0.5);
      const steps = 14;
      const cx = anchor.x + (Math.random()*30-15);
      const cy = anchor.y + (Math.random()*30-15);
      const startA = Math.random()*Math.PI*2;
      for(let i=1;i<=steps;i++){
        const a = startA + span*(i/steps);
        pts.push({x: cx + Math.cos(a)*radius, y: cy + Math.sin(a)*radius});
      }
    }else if(style<0.75){
      const radius = 46 + Math.random()*14;
      const steps = 10;
      const dx = (Math.random()<0.5?-1:1)*(30+Math.random()*20);
      const dy = (Math.random()<0.5?-1:1)*(20+Math.random()*20);
      for(let i=1;i<=steps;i++){
        const t=i/steps;
        const a = Math.sin(t*Math.PI)*Math.PI*0.9;
        pts.push({x: anchor.x + dx*t + Math.cos(a)*radius*0.5, y: anchor.y + Math.sin(a)*radius});
      }
    }else{
      const bump = 32 + Math.random()*18;
      const steps = 12;
      for(let i=1;i<=steps;i++){
        const t=i/steps;
        const a=t*Math.PI*2;
        pts.push({x: anchor.x + Math.cos(a)*bump*0.7, y: anchor.y + Math.sin(a)*bump});
      }
    }
    const rejoinIdx = Math.min(path.length-1, startIdx+4);
    pts.push(path[rejoinIdx]);
    return {points:pts, rejoinIdx};
  }

  // æ•µäººèˆ‡å¡”
  const ENEMY={
    virus:{hp:30, spd:110, reward:9, r:9, color:'#6ec1ff'},
    bacteria:{hp:60, spd:55, reward:10, r:11, color:'#86e3a6'},
    fungus:{hp:110, spd:45, reward:14, r:12, color:'#c7a6ff'},
    protozoa:{hp:85, spd:85, reward:16, r:11, color:'#ffb3a6'},
    helminth:{hp:220, spd:38, reward:22, r:13, color:'#ffd166'},
    intracellular:{hp:95, spd:115, reward:20, r:10, color:'#9ae6b4'}
  };
  const TOWER={
    COMPLEMENT:{cost:70, range:150, rof:0.85, dmg:4, color:'#9ad8ff', mark:true, synergy:0.6},
    MACRO:{cost:80, range:140, rof:0.65, dmg:18, color:'#7be3b0', bonusVsMarked:0.3},
    INFLAM:{cost:70, range:180, rof:0.7, dmg:2, color:'#ffa8a8', slow:0.5, splash:28},
    ANTIBODY:{cost:90, range:230, rof:0.55, dmg:9, color:'#ffd166', bonusVsMarked:0.6}
  };
  const BOSS_DEF={
    4:{name:'è¢è†œå·¨æ€ª', color:'#ff9e3d', shape:'hex', hp:1200, spd:60, r:22, reward:200,
       onTick:(b,dt)=>{ b.spawnCd=(b.spawnCd||0)-dt; if(b.spawnCd<=0){ b.spawnCd=2.2; spawnMinions(3); }}},
    8:{name:'è®Šç•°é¢¨æš´', color:'#3ce8ff', shape:'star', hp:1800, spd:80, r:24, reward:320,
       onTick:(b,dt)=>{ b.dashCd=(b.dashCd||0)-dt; if(b.dashCd<=0){ b.dashCd=3.2; b.dashTime=1.0; } if(b.dashTime>0){ b.dashTime-=dt; b.ignoreSlow=true; } else { b.ignoreSlow=false; }}},
    12:{name:'è •èŸ²å¥³ç‹', color:'#ff4ddb', shape:'worm', hp:2600, spd:42, r:26, reward:500,
        onTick:(b,dt)=>{ b.shieldCd=(b.shieldCd||0)-dt; if(b.shieldCd<=0){ b.shieldCd=4.0; b.shieldTime=1.2; } if(b.shieldTime>0){ b.shieldTime-=dt; b.shielded=true; } else { b.shielded=false; }}}
  };

  // è§£é–è¡¨èˆ‡æ³¢æ¬¡
  const typeUnlockSchedule = [
    {wave:1, add:[]},
    {wave:3, add:['fungus']},
    {wave:5, add:['protozoa']},
    {wave:7, add:['helminth']},
    {wave:9, add:['intracellular']},
    {wave:11, add:[]}
  ];
  function unlockByWave(w){
    for(const s of typeUnlockSchedule){
      if(s.wave===w){ for(const t of s.add){ if(!state.unlockedTypes.includes(t)) state.unlockedTypes.push(t);} }
    }
  }
  const waves=[];
  for(let w=1; w<=12; w++){
    unlockByWave(w);
    const pack=[];
    const countBase = 7 + Math.floor(w*1.2);
    const types = [...state.unlockedTypes];
    if(w===4 || w===8 || w===12){
      for(let i=0;i<Math.max(4, Math.floor(countBase*0.5)); i++){
        const t = types[Math.floor(Math.random()*types.length)];
        pack.push({t, at:0.5 + i*0.9});
      }
      pack.push({boss:true, at:2.0});
    }else{
      for(let i=0;i<countBase;i++){
        const t = types[Math.floor(Math.random()*types.length)];
        pack.push({t, at:0.35 + i*0.85});
      }
    }
    waves.push(pack);
  }

  function addCP(v){state.cp=Math.max(0,state.cp+v); ui.cp.textContent = Math.round(state.cp);}

  // å·¥å…·åˆ—é¸æ“‡
  const buildTools=[...document.querySelectorAll('.tool[data-type]')];
  buildTools.forEach(el=>el.addEventListener('click',()=>{
    buildTools.forEach(x=>x.classList.remove('selected')); el.classList.add('selected');
    placing=el.dataset.type; selected=null;
  }));

  function upgradeCost(t){ return UPGRADE_BASE + UPGRADE_STEP*(t.lvl-1); }
  $('up').addEventListener('click',()=>{
    if(!selected || state.gameOver) return;
    if(selected.lvl>=MAX_LVL) return;
    const cost = upgradeCost(selected);
    if(state.cp<cost) return;
    addCP(-cost);
    selected.lvl++;
    selected.dmg*=1.2; selected.rof*=1.12; selected.range*=1.08;
  });
  $('sell').addEventListener('click',()=>{
    if(!selected || state.gameOver) return;
    const node=state.nodes.find(n=>n.tower===selected);
    const base=TOWER[selected.kind].cost;
    addCP(Math.floor(base*0.6 + (selected.lvl-1)*18));
    state.towers=state.towers.filter(t=>t!==selected);
    if(node) node.tower=null; selected=null;
  });

  $('swell').addEventListener('click',()=>{
    const now=performance.now()/1000;
    if(state.cp<50 || state.gameOver) return;
    if(now < state.ability.swellCdUntil) return;
    let node=null;
    if(selected){ node=state.nodes.find(n=>n.tower===selected); }
    if(!node) node=state.nodes[Math.floor(state.nodes.length/2)];
    if(node.gate.cdUntil>now) return;
    node.gate.activeUntil = now + 12;
    node.gate.cdUntil = now + state.ability.swellCdDur;
    state.ability.swellCdUntil = now + state.ability.swellCdDur;
    addCP(-50);
  });

  $('chaser').addEventListener('click',()=>{
    const now=performance.now()/1000;
    if(state.cp<60 || state.gameOver) return;
    if(now < state.ability.chaserCdUntil) return;
    let startPos=null;
    if(selected){
      const node=state.nodes.find(n=>n.tower===selected);
      if(node) startPos={x:node.x, y:node.y};
    }
    if(!startPos){ const n=state.nodes[Math.floor(state.nodes.length/2)] || {x:W*0.5,y:H*0.5}; startPos={x:n.x, y:n.y}; }
    state.chasers.push({x:startPos.x,y:startPos.y, vx:0, vy:0, spd:240, dmg:22, r:9, life:10.0, atkCd:0});
    state.ability.chaserCdUntil = now + state.ability.chaserCdDur;
    addCP(-60);
  });

  // é»æ“Šç«™é»æ”¾å¡” / é¸å¡”
  cnv.addEventListener('click',(ev)=>{
    if(state.gameOver) return;
    const rect=cnv.getBoundingClientRect();
    const mx=(ev.clientX-rect.left)*(cnv.width/rect.width);
    const my=(ev.clientY-rect.top)*(cnv.height/rect.height);
    let hit=null;
    for(const n of state.nodes){ if(Math.hypot(n.x-mx, n.y-my)<=n.r){ hit=n; break; } }
    if(hit){
      if(placing){ build(hit, placing); }
      else { selected = hit.tower || null; }
      return;
    }
    selected=null;
  });

  function build(node, kind){
    if(node.tower) { selected=node.tower; return; }
    const data={...TOWER[kind]};
    if(state.cp<data.cost) return;
    addCP(-data.cost);
    const t={kind, x:node.x, y:node.y, range:data.range, rof:data.rof, dmg:data.dmg, cd:0, lvl:1, color:data.color, nodeId:node.id};
    if(kind==='COMPLEMENT'){ t.mark=true; t.synergy=data.synergy; }
    if(kind==='MACRO'){ t.bonusVsMarked=data.bonusVsMarked; }
    if(kind==='INFLAM'){ t.slow=data.slow; t.splash=data.splash; }
    if(kind==='ANTIBODY'){ t.bonusVsMarked=data.bonusVsMarked; }
    node.tower=t; state.towers.push(t); selected=t;
  }

  // åˆå§‹ç”Ÿæˆè·¯å¾‘ä¾›éƒ¨ç½²åƒè€ƒ
  function initPath(){
    state.basePath = generateMixedPath();
    for(const n of state.nodes){
      const idx = nearestPathIdx(n, state.basePath);
      n.gate.startIdx=idx; n.gate.loop = makeVariedDetour(state.basePath, idx);
    }
  }
  initPath();

  // é–‹æ³¢
  function startWave(){
    if(state.wave>=state.wmax || state.gameOver) return;
    // æ¯æ³¢å‰é‡ç¹ªè·¯ç·š
    if(state.enemies.length===0 && state.queue.length===0){
      state.basePath = generateMixedPath();
      for(const n of state.nodes){
        const idx = nearestPathIdx(n, state.basePath);
        n.gate.startIdx = idx;
        n.gate.loop = makeVariedDetour(state.basePath, idx);
        n.gate.activeUntil = 0;
      }
    }
    state.wave++; ui.wave.textContent=state.wave;

    if(state.wave===4 || state.wave===8 || state.wave===12){
      addNewStations(2);
      flashToast('æ–°å¢ 2 å€‹ç«™é»ï¼');
    }

    state.queue.length=0;
    const pack=waves[state.wave-1];
    const baseAt = state.time + 0.2;
    for(const s of pack) state.queue.push({t:s.t, boss:!!s.boss, at:baseAt+s.at});
  }

  function addNewStations(k){
    const margin=50, minDist=100; let tries=0;
    while(k>0 && tries<800){
      tries++;
      const x = margin + Math.random()*(W-2*margin);
      const y = margin + Math.random()*(H-2*margin);
      let ok=true;
      for(const n of state.nodes){
        if(Math.hypot(n.x-x, n.y-y) < minDist){ ok=false; break; }
      }
      if(ok){
        const id = state.nodes.length;
        const node={id, x, y, r:24, tower:null, gate:{startIdx:0, loop:null, activeUntil:0, cdUntil:0}};
        state.nodes.push(node);
        k--;
      }
    }
  }

  function flashToast(msg){
    const d=document.createElement('div');
    d.textContent=msg;
    d.style.position='absolute'; d.style.left='50%'; d.style.top='10px'; d.style.transform='translateX(-50%)';
    d.style.background='rgba(0,0,0,.6)'; d.style.border='1px solid #335'; d.style.padding='8px 12px'; d.style.borderRadius='10px';
    d.style.color='#fff'; d.style.zIndex='9'; d.style.pointerEvents='none';
    document.getElementById('gamebox').appendChild(d);
    setTimeout(()=>{ d.style.transition='opacity .6s'; d.style.opacity='0'; setTimeout(()=>d.remove(),600); }, 1200);
  }

  // ç§»å‹•èˆ‡æˆ°é¬¥
  function stepEnemy(e,dt){
    if(state.gameOver) return;
    if(e.dead) return;
    const now=performance.now()/1000;
    if(e.boss && e.onTick) e.onTick(e,dt);
    const upcomingIdx = e.subpath ? -1 : e.wp;
    if(upcomingIdx>=0){
      const nd = state.nodes.find(n=>n.gate.startIdx===upcomingIdx);
      if(nd && nd.gate.activeUntil>now){
        e.subpath = nd.gate.loop.points.slice(); e.subWp = 1;
      }
    }
    if(e.subpath){
      const target=e.subpath[e.subWp];
      if(!target){
        e.subpath=null; e.subWp=0; e.wp = Math.max(e.wp, e.wp+1);
      }else{
        moveTowards(e, target, dt);
        if(Math.hypot(target.x-e.x, target.y-e.y)<2){ e.subWp++; }
      }
      return;
    }
    const target = state.basePath[e.wp];
    if(!target){
      // åªæœ‰é€ƒå‡ºæ‰æ‰£ç”Ÿå‘½
      e.dead=true; e.wp = state.basePath.length;
      state.lives--; ui.lives.textContent=state.lives;
      if(state.lives<=0) state.gameOver=true;
      return;
    }
    moveTowards(e, target, dt);
    if(Math.hypot(target.x-e.x, target.y-e.y)<2){ e.wp++; }
  }
  function moveTowards(e, target, dt){
    const dx=target.x-e.x, dy=target.y-e.y; const d=Math.hypot(dx,dy)||1;
    let sp=e.spd*(1 - Math.min(0.6, e.slow));
    if(e.boss && e.ignoreSlow) sp=e.spd*(1.6);
    e.x += (dx/d)*sp*dt; e.y += (dy/d)*sp*dt;
    e.slow=Math.max(0, e.slow - dt*0.8);
  }

  function stepTower(t,dt){
    if(state.gameOver) return;
    t.cd=Math.max(0,t.cd-dt);
    let target=null, best=1e9;
    for(const e of state.enemies){
      if(e.dead) continue;
      const d=Math.hypot(t.x-e.x, t.y-e.y);
      if(d<=t.range && d<best){ best=d; target=e; }
    }
    if(target && t.cd<=0){
      fire(t,target);
      t.cd=1/t.rof;
    }
  }
  function fire(t,e){
    const baseSp = (t.kind==='ANTIBODY')? 180 : (t.kind==='INFLAM'?240:230);
    const ang=Math.atan2(e.y-t.y, e.x-t.x);
    const p={x:t.x,y:t.y, vx:Math.cos(ang)*baseSp, vy:Math.sin(ang)*baseSp,
             dmg:t.dmg, kind:t.kind, life:3.0, bonus:t.bonusVsMarked||0,
             mark:!!t.mark, slow:t.slow||0, splash:t.splash||0, synergy:t.synergy||0};
    if(t.kind==='ANTIBODY'){ p.homing=true; p.target=e; p.turn=6.0; }
    state.projs.push(p);
  }
  function stepProj(p,dt){
    if(state.gameOver) return;
    if(p.homing){
      if(!p.target || p.target.dead){
        let nearest=null, best=1e9;
        for(const e of state.enemies){
          if(e.dead) continue;
          const d=Math.hypot(p.x-e.x, p.y-e.y);
          if(d<best){ best=d; nearest=e; }
        }
        p.target=nearest;
      }
      if(p.target){
        const desiredAng=Math.atan2(p.target.y-p.y, p.target.x-p.x);
        const curAng=Math.atan2(p.vy, p.vx);
        let diff = desiredAng - curAng;
        while(diff>Math.PI) diff-=2*Math.PI;
        while(diff<-Math.PI) diff+=2*Math.PI;
        const maxTurn=(p.turn||6)*dt;
        const newAng = curAng + Math.max(-maxTurn, Math.min(maxTurn, diff));
        const speed = Math.hypot(p.vx,p.vy);
        p.vx=Math.cos(newAng)*speed; p.vy=Math.sin(newAng)*speed;
      }
    }
    p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt;
    for(const e of state.enemies){
      if(e.dead) continue;
      const hitR = (p.kind==='ANTIBODY' || p.kind==='MACRO')? (e.r+6) : (e.r+4);
      if(Math.hypot(p.x-e.x, p.y-e.y) < hitR){
        applyHit(e, p);
        if(p.kind==='INFLAM' && p.splash){
          for(const e2 of state.enemies){
            if(e2===e || e2.dead) continue;
            if(Math.hypot(p.x-e2.x, p.y-e2.y) <= p.splash){ applyHit(e2, p, true); }
          }
        }
        state.crumb.push({x:e.x,y:e.y,life:0.18});
        p.life=0;
      }
    }
  }
  function applyHit(target, p, splash=false){
    let dmg=p.dmg;
    if(target.boss && target.shielded) dmg *= 0.5;
    if(p.kind==='MACRO' && target.marked) dmg *= (1 + (p.bonus||0.3));
    if(p.kind==='ANTIBODY' && target.marked) dmg *= (1 + (p.bonus||0.6));
    if(p.kind==='COMPLEMENT') target.marked=true;
    if(p.slow && !target.ignoreSlow) target.slow=Math.max(target.slow, splash? p.slow*0.8 : p.slow);
    target.hp -= dmg;
    if(target.hp<=0){
      target.dead=true;
      const waveMul = 1 + (state.wave-1)*0.5;
      const base = (target.boss ? BOSS_DEF[state.wave].reward : (target.reward||10));
      addCP(Math.round(base * waveMul));
      if(target.boss && state.wave===12){ spawnMinions(6); }
    }
  }

  function spawnMinions(n){
    for(let i=0;i<n;i++){
      const t = (Math.random()<0.5)?'virus':'bacteria';
      const base = state.basePath[0] || {x:10,y:H*0.5};
      state.enemies.push({type:t, x:base.x, y:base.y, wp:1, hp:ENEMY[t].hp, maxhp:ENEMY[t].hp, spd:ENEMY[t].spd, r:ENEMY[t].r, color:ENEMY[t].color, reward:ENEMY[t].reward, marked:false, slow:0, dead:false, subpath:null, subWp:0});
    }
  }

  // è¿½æ“Šæ·‹å·´çƒï¼ˆIL-2ï¼‰
  function stepChaser(c,dt){
    c.life -= dt; if(c.life<=0) return;
    // æ‰¾æœ€è¿‘æ•µäºº
    let tgt=null, best=1e9;
    for(const e of state.enemies){
      if(e.dead) continue;
      const d=Math.hypot(e.x-c.x, e.y-c.y);
      if(d<best){ best=d; tgt=e; }
    }
    if(tgt){
      // è½‰å‘è¿½è¹¤
      const desired=Math.atan2(tgt.y-c.y, tgt.x-c.x);
      const cur=Math.atan2(c.vy||0.0001, c.vx||1);
      let diff=desired-cur;
      while(diff>Math.PI) diff-=2*Math.PI;
      while(diff<-Math.PI) diff+=2*Math.PI;
      const turn=6.5*dt;
      const ang=cur + Math.max(-turn, Math.min(turn, diff));
      c.vx=Math.cos(ang)*c.spd; c.vy=Math.sin(ang)*c.spd;
      c.x += c.vx*dt; c.y += c.vy*dt;
      // è¿‘è·æ”»æ“Šï¼ˆ0.25s ç¯€å¥ï¼‰
      c.atkCd = (c.atkCd||0) - dt;
      if(best < (tgt.r+10) && c.atkCd<=0){
        tgt.hp -= 22;
        c.atkCd = 0.25;
        if(tgt.hp<=0) tgt.dead=true;
      }
    }
  }

  // ç¹ªè£½
  function drawPath(points){
    if(points.length<3) return;
    const penult=points[points.length-2], lastp=points[points.length-1];
    ctx.strokeStyle='#134f7a'; ctx.lineWidth=26; ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
    for(let i=1;i<points.length-2;i++){
      const xc=(points[i].x + points[i+1].x)/2, yc=(points[i].y + points[i+1].y)/2;
      ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
    }
    ctx.quadraticCurveTo(penult.x, penult.y, lastp.x, lastp.y); ctx.stroke();
    ctx.strokeStyle='rgba(123,227,176,0.35)'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
    for(let i=1;i<points.length-2;i++){
      const xc=(points[i].x + points[i+1].x)/2, yc=(points[i].y + points[i+1].y)/2;
      ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
    }
    ctx.quadraticCurveTo(penult.x, penult.y, lastp.x, lastp.y); ctx.stroke();
  }

  function draw(){
    ctx.fillStyle='#081224'; ctx.fillRect(0,0,W,H);
    if(state.basePath.length>1) drawPath(state.basePath);
    for(const n of state.nodes){
      const loop=n.gate.loop? n.gate.loop.points : null;
      if(loop){
        ctx.strokeStyle='rgba(255,209,102,0.25)'; ctx.lineWidth=8;
        ctx.beginPath(); ctx.moveTo(loop[0].x, loop[0].y);
        for(let i=1;i<loop.length;i++){
          const prev=loop[i-1], cur=loop[i];
          const midx=(prev.x+cur.x)/2, midy=(prev.y+cur.y)/2;
          ctx.quadraticCurveTo(prev.x, prev.y, midx, midy);
        } ctx.stroke();
      }
      ctx.fillStyle='#0d2c54'; ctx.beginPath(); ctx.arc(n.x,n.y,n.r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#2a5d9a'; ctx.lineWidth=2; ctx.stroke();
      if(n.tower){
        const t=n.tower;
        ctx.fillStyle=t.color; ctx.beginPath(); ctx.arc(n.x,n.y,12,0,Math.PI*2); ctx.fill();
        if(selected===t){
          ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(t.x,t.y,t.range,0,Math.PI*2); ctx.stroke();
        }
      }
    }
    for(const e of state.enemies){
      if(e.dead) continue;
      const ratio=e.hp/e.maxhp;
      if(e.boss){
        ctx.save(); ctx.translate(e.x, e.y);
        ctx.fillStyle=e.color; ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=2;
        // boss å½¢ç‹€ç°¡åŒ–é¡¯ç¤º
        ctx.beginPath(); for(let i=0;i<6;i++){ const a=i*Math.PI/3; const r=e.r+6; const x=Math.cos(a)*r, y=Math.sin(a)*r; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
        ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
      }else{
        ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();
      }
      ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(e.x,e.y,(e.boss? e.r+10: e.r+3),-Math.PI/2,-Math.PI/2+Math.PI*2*ratio); ctx.stroke();
      if(e.marked){ ctx.strokeStyle='rgba(255,230,140,.9)'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(e.x,e.y,(e.boss? e.r+14: e.r+6),0,Math.PI*2); ctx.stroke(); }
    }
    for(const p of state.projs){
      const isAB = (p.kind==='ANTIBODY');
      ctx.fillStyle = isAB ? '#ffe08a' : (p.kind==='INFLAM' ? '#ffa8a8' : (p.kind==='COMPLEMENT' ? '#9ad8ff' : '#7be3b0'));
      ctx.beginPath(); ctx.arc(p.x,p.y, isAB?5:4,0,Math.PI*2); ctx.fill();
      if(p.kind==='INFLAM' && p.splash){ ctx.globalAlpha=0.15; ctx.beginPath(); ctx.arc(p.x,p.y,p.splash,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
    }
    for(const c of state.chasers){
      if(c.life<=0) continue;
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle='#ffffff'; ctx.beginPath(); ctx.arc(c.x, c.y, c.r, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='rgba(135,206,250,0.9)'; ctx.beginPath(); ctx.arc(c.x+1.5, c.y+1.5, c.r*0.5, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
    for(const c of state.crumb){
      ctx.globalAlpha=Math.max(0,c.life/0.18);
      ctx.fillStyle='#fff'; ctx.fillRect(c.x-1,c.y-1,2,2);
      ctx.globalAlpha=1;
    }
    // å†·å»æ¢
    const now=performance.now()/1000;
    if(state.ability.swellCdUntil > now){
      const remain = state.ability.swellCdUntil - now;
      cdSwell.style.width = (Math.max(0,Math.min(1, remain / state.ability.swellCdDur))*100).toFixed(1)+'%';
    }else{ cdSwell.style.width = '0%'; }
    if(state.ability.chaserCdUntil > now){
      const remain = state.ability.chaserCdUntil - now;
      cdChaser.style.width = (Math.max(0,Math.min(1, remain / state.ability.chaserCdDur))*100).toFixed(1) + '%';
    }else{ cdChaser.style.width = '0%'; }

    if(state.gameOver){
      ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.font='28px sans-serif';
      const text='æ•—åŒ—ï¼æ·‹å·´é˜²ç·šè¢«çªç ´'; const tw=ctx.measureText(text).width; ctx.fillText(text,(W-tw)/2,H/2);
    }
    if(state.victory){
      ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#7be3b0'; ctx.font='32px sans-serif';
      const text='å‹åˆ©ï¼æˆåŠŸå®ˆä½ 12 æ³¢'; const tw=ctx.measureText(text).width; ctx.fillText(text,(W-tw)/2,H/2);
    }
  }

  // è‡ªå‹•ä¸‹ä¸€æ³¢ 5 ç§’åœ“å½¢å€’æ•¸
  function updateAutoNext(dt){
    const clear = (state.enemies.length===0 && state.queue.length===0);
    const canNext = (!state.gameOver && !state.victory && state.wave < state.wmax);
    if(state.wave>0 && clear && canNext){
      if(!autoActive){ autoActive=true; autoTimer=5; autoBox.style.display='block'; autoProg.style.strokeDashoffset=283; }
      autoTimer -= dt;
      autoNum.textContent = Math.ceil(Math.max(0,autoTimer));
      const p = Math.min(1, Math.max(0, (5-autoTimer)/5 ));
      autoProg.style.strokeDashoffset = (283*(1-p));
      if(autoTimer<=0){
        autoActive=false; autoBox.style.display='none';
        startWave();
      }
    }else{
      if(autoActive){ autoActive=false; autoBox.style.display='none'; }
    }
  }

  // ä¸»è¿´åœˆ
  let last=performance.now();
  function loop(ts){
    const dt=Math.min(0.05,(ts-last)/1000); last=ts;
    if(!paused){
      state.time+=dt;
      // ç”Ÿæˆæ•µäºº
      while(state.queue.length && state.queue[0].at<=state.time){
        const s=state.queue.shift();
        if(s.boss){
          const def=BOSS_DEF[state.wave];
          const base = state.basePath[0] || {x:10,y:H*0.5};
          state.enemies.push({boss:true, name:def.name, x:base.x, y:base.y, wp:1, hp:def.hp, maxhp:def.hp, spd:def.spd, r:def.r, color:def.color,
             reward:def.reward, marked:false, slow:0, dead:false, subpath:null, subWp:0, onTick:def.onTick, ignoreSlow:false, shielded:false, shape:def.shape});
        } else {
          const t=s.t || 'virus';
          const base = state.basePath[0] || {x:10,y:H*0.5};
          const eDef=ENEMY[t];
          state.enemies.push({type:t, x:base.x, y:base.y, wp:1, hp:eDef.hp, maxhp:eDef.hp, spd:eDef.spd, r:eDef.r, color:eDef.color, reward:eDef.reward, marked:false, slow:0, dead:false, subpath:null, subWp:0});
        }
      }
      // ç§»å‹•èˆ‡æˆ°é¬¥
      for(const e of state.enemies) stepEnemy(e,dt);
      state.enemies=state.enemies.filter(e=>!e.dead);
      for(const t of state.towers) stepTower(t,dt);
      for(const p of state.projs) stepProj(p,dt);
      state.projs=state.projs.filter(p=>p.life>0);
      for(const c of state.chasers) stepChaser(c,dt);
      state.chasers=state.chasers.filter(c=>c.life>0);
      if(state.wave===state.wmax && state.enemies.length===0 && state.queue.length===0) state.victory=true;
    }
    updateAutoNext(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // æš«åœ/ç¹¼çºŒ
  btn.pause.textContent='ç¹¼çºŒ';
  btn.pause.addEventListener('click',()=>{
    if(state.gameOver || state.victory) return;
    paused=!paused; btn.pause.textContent=paused?'ç¹¼çºŒ':'æš«åœ';
    if(!paused && state.wave===0){
      startWave(); // æŒ‰ã€Œç¹¼çºŒã€å°±é–‹ç¬¬ 1 æ³¢
    }
  });
  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space'){
      e.preventDefault();
      if(!state.gameOver && !state.victory){
        paused=!paused; btn.pause.textContent=paused?'ç¹¼çºŒ':'æš«åœ';
        if(!paused && state.wave===0){
          startWave();
        }
      }
    } else if(e.key==='Escape'){
      modal.style.display='none';
    }
  }, {passive:false});
  window.addEventListener('blur', ()=>{ if(!state.gameOver && !state.victory){ paused=true; btn.pause.textContent='ç¹¼çºŒ'; } });

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
