<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>淋巴守城：生命僅逃出-1 / 正確暫停文字</title>
<style>
  :root{--bg:#0b1020; --panel:#101935; --text:#eaf1ff; --acc:#7be3b0; --warn:#ffd166; --danger:#ff6b6b;}
  *{box-sizing:border-box; font-family: system-ui, -apple-system, "Noto Sans TC", "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body{margin:0; background:linear-gradient(180deg,#0b1020 0%, #0f1a3a 100%); color:var(--text);}
  header{display:flex;align-items:center;gap:.6rem; padding:.7rem 1rem; background:#0d1633; position:sticky; top:0; z-index:5; box-shadow:0 2px 8px rgba(0,0,0,.4)}
  .stat{padding:.35rem .6rem; border:1px solid #1f2b55; border-radius:10px; background:#0f1a3a; font-weight:700}
  header button{appearance:none;border:none;border-radius:10px; padding:.55rem .8rem; background:#1a3568; color:#d8e8ff; cursor:pointer; position:relative; overflow:hidden}
  header button:hover{background:#23457f}
  #wrap{display:grid; grid-template-columns:1fr; justify-items:center; padding:10px}
  #gamebox{position:relative; width:min(1100px,96vw); aspect-ratio:16/9; background:#081224; border:1px solid #1a2a54; border-radius:16px; overflow:hidden; box-shadow:0 6px 24px rgba(0,0,0,.5)}
  canvas{width:100%; height:100%; display:block}
  #panel{display:flex;gap:.6rem;flex-wrap:wrap; padding:8px 0}
  .tool{display:flex;align-items:center;gap:.4rem; padding:.5rem .7rem; border:1px solid #2a3c74; border-radius:10px; background:#0f1c3d; cursor:pointer; position:relative; overflow:hidden}
  .tool strong{letter-spacing:.5px}
  .tool .cost{opacity:.85}
  .selected{outline:2px solid var(--acc)}
  .cdbar{position:absolute; left:0; top:0; height:100%; width:0%; background:rgba(255,255,255,0.18); pointer-events:none; transition:width .1s linear}

  #autonext{position:absolute; right:12px; bottom:12px; background:rgba(15,26,58,0.9); border:1px solid #2b457a;
            color:#eaf1ff; padding:8px 12px; border-radius:10px; display:none; align-items:center; gap:10px}
  #autonext .bar{width:140px; height:8px; background:#0c1733; border:1px solid #2a3c74; border-radius:6px; overflow:hidden}
  #autonext .bar > span{display:block; height:100%; width:0%; background:linear-gradient(90deg, #7be3b0, #ffd166)}
</style>
</head>
<body>
<header>
  <div class="stat">CP：<span id="cp">0</span></div>
  <div class="stat">Wave：<span id="wave">0</span>/<span id="wmax">12</span></div>
  <div class="stat">Lives：<span id="lives">15</span></div>
  <button id="pause">繼續</button>
  <button id="help">教學</button>
</header>

<div id="wrap">
  <div id="gamebox">
    <canvas id="game" width="1152" height="648"></canvas>
    <div id="autonext"><span>下一波倒數中…</span><div class="bar"><span id="autobar"></span></div></div>
  </div>
  <div id="panel">
    <div class="tool" data-type="COMPLEMENT"><span class="cdbar"></span><strong>補體系統</strong><span class="cost">CP 70</span><span>（貼標＋輕傷）</span></div>
    <div class="tool" data-type="MACRO"><span class="cdbar"></span><strong>巨噬細胞</strong><span class="cost">CP 80</span><span>（單體高傷）</span></div>
    <div class="tool" data-type="INFLAM"><span class="cdbar"></span><strong>發炎介質</strong><span class="cost">CP 70</span><span>（範圍減速）</span></div>
    <div class="tool" data-type="ANTIBODY"><span class="cdbar"></span><strong>抗體</strong><span class="cost">CP 90</span><span>（追蹤強擊）</span></div>
    <div class="tool" id="up"><span class="cdbar"></span><strong>升級（等差成本）</strong><span class="cost">基礎 60，每級 +20（Lv≤5）</span></div>
    <div class="tool" id="sell"><span class="cdbar"></span><strong>出售</strong><span class="cost">返還60%</span></div>
    <div class="tool" id="swell"><span class="cdbar" id="cd_swell"></span><strong>淋巴結腫大</strong><span class="cost">CP 50</span><span>（變異繞路12s / 冷卻20s）</span></div>
    <div class="tool" id="chaser"><span class="cdbar" id="cd_chaser"></span><strong>追擊淋巴球（IL‑2）</strong><span class="cost">CP 60</span><span>（壽命 10s / 冷卻15s）</span></div>
  </div>
</div>

<script>
(()=>{
  function $(id){return document.getElementById(id);}
  const W=1152,H=648;
  const cnv=$('game'); const ctx=cnv.getContext('2d');
  const ui={cp:$('cp'), wave:$('wave'), lives:$('lives')};
  const btn={pause:$('pause'), help:$('help')};
  const cdSwell=$('cd_swell'), cdChaser=$('cd_chaser');
  const autoBox=document.getElementById('autonext');
  const autoBar=document.getElementById('autobar');
  let placing=null, selected=null, paused=true, started=false;
  let autoTimer=10, autoActive=false;

  const UPGRADE_BASE=60, UPGRADE_STEP=20, MAX_LVL=5;

  const state={
    cp:250, lives:15, wave:0, wmax:12, time:0, gameOver:false, victory:false,
    basePath:[], enemies:[], towers:[], projs:[], crumb:[], queue:[],
    nodes:[], chasers:[],
    ability:{ swellCdDur:20, swellCdUntil:0, chaserCdDur:15, chaserCdUntil:0 },
    unlockedTypes:['virus','bacteria'],
  };
  ui.cp.textContent=state.cp; ui.wave.textContent=state.wave; ui.lives.textContent=state.lives;

  // 教學僅按需開啟
  const modal = document.createElement('div'); // 省略內容，承襲上一版，為簡化此檔不再重複教學HTML
  // 若需要完整教學頁，仍可使用上一版 full tutorial 檔。

  function scatterRandomNodes(count){
    const nodes=[];
    const margin=50, minDist=110;
    let guard=0;
    while(nodes.length<count && guard<2000){
      guard++;
      const x = margin + Math.random()*(W-2*margin);
      const y = margin + Math.random()*(H-2*margin);
      let ok=true;
      for(const n of nodes){
        if(Math.hypot(n.x-x, n.y-y) < minDist){ ok=false; break; }
      }
      if(ok) nodes.push({id:nodes.length, x, y, r:24, tower:null, gate:{startIdx:0, loop:null, activeUntil:0, cdUntil:0}});
    }
    return nodes;
  }
  state.nodes = scatterRandomNodes(6);

  function dist(a,b){return Math.hypot(a.x-b.x, a.y-b.y);}
  function segDist(p,a,b){
    const A={x:a.x,y:a.y}, B={x:b.x,y:b.y};
    const AP={x:p.x-A.x, y:p.y-A.y}, AB={x:B.x-A.x, y:B.y-A.y};
    const ab2=AB.x*AB.x+AB.y*AB.y; if(ab2===0) return dist(p,A);
    let t=(AP.x*AB.x + AP.y*AB.y)/ab2; t=Math.max(0,Math.min(1,t));
    const C={x:A.x+AB.x*t, y:A.y+AB.y*t};
    return dist(p,C);
  }
  function tooCloseToExisting(p, pts, minD, ignoreLastN=8){
    const L=pts.length;
    for(let i=1;i<L;i++){
      if(L-i <= ignoreLastN) continue;
      if(segDist(p, pts[i-1], pts[i]) < minD) return true;
    }
    return false;
  }
  function nearestPathIdx(node, path){
    let best=0, bestD=1e9;
    for(let i=0;i<path.length;i++){
      const dx=node.x-path[i].x, dy=node.y-path[i].y;
      const d=dx*dx+dy*dy;
      if(d<bestD){ bestD=d; best=i; }
    }
    return Math.max(1, Math.min(path.length-2, best));
  }
  function generateMixedPath(){
    const margin=30, visitR=24, minSegGap=22;
    const pts=[];
    const sorted=[...state.nodes].sort((a,b)=>a.x-b.x);
    pts.push({x:margin, y:H*0.5});
    for(let i=0;i<sorted.length;i++){
      const n=sorted[i];
      let ax = Math.max(margin, Math.min(W-margin, n.x - (50+Math.random()*40)));
      let ay = Math.max(margin, Math.min(H-margin, (pts[pts.length-1].y*0.65 + n.y*0.35) + (Math.random()*30-15)));
      let ptA={x:ax,y:ay};
      let guard=0; while(tooCloseToExisting(ptA, pts, minSegGap) && guard<8){ ay += (Math.random()<0.5?-1:1)*10; ptA={x:ax,y:Math.max(margin,Math.min(H-margin,ay))}; guard++; }
      pts.push(ptA);
      const arcSteps= 5 + Math.floor(Math.random()*3);
      const rad = visitR + 4 + Math.random()*8;
      const cw = Math.random()<0.5? -1: 1;
      const baseA = Math.random()*Math.PI*2;
      const span = Math.PI*(0.6 + Math.random()*0.9);
      for(let s=0;s<=arcSteps;s++){
        const a = baseA + cw * span * (s/arcSteps);
        const p={x:n.x + Math.cos(a)*rad, y:n.y + Math.sin(a)*rad};
        if(tooCloseToExisting(p, pts, minSegGap)) { p.y += (Math.random()<0.5?-1:1)*12; }
        p.x=Math.max(margin,Math.min(W-margin,p.x));
        p.y=Math.max(margin,Math.min(H-margin,p.y));
        pts.push(p);
      }
      let bx = Math.max(margin, Math.min(W-margin, n.x + (55+Math.random()*45)));
      let by = Math.max(margin, Math.min(H-margin, n.y + (Math.random()*34-17)));
      let ptB={x:bx,y:by};
      guard=0; while(tooCloseToExisting(ptB, pts, minSegGap) && guard<8){ by += (Math.random()<0.5?-1:1)*10; ptB={x:bx,y:Math.max(margin,Math.min(H-margin,by))}; guard++; }
      pts.push(ptB);
      if(i<sorted.length-1){
        if(Math.random()<0.6){
          const nxt=sorted[i+1];
          const mx=(n.x+nxt.x)/2, my=((n.y+nxt.y)/2) + (Math.random()*20-10);
          const q={x:mx, y:Math.max(margin,Math.min(H-margin,my))};
          if(!tooCloseToExisting(q, pts, minSegGap)) pts.push(q);
        }else{
          const nxt=sorted[i+1];
          const mx=(n.x*0.7+nxt.x*0.3);
          const my=(n.y*0.7+nxt.y*0.3) + (Math.random()*24-12);
          const q1={x:mx, y:Math.max(margin,Math.min(H-margin,my))};
          if(!tooCloseToExisting(q1, pts, minSegGap)) pts.push(q1);
          const mx2=(n.x*0.3+nxt.x*0.7);
          const my2=(n.y*0.3+nxt.y*0.7) + (Math.random()*24-12);
          const q2={x:mx2, y:Math.max(margin,Math.min(H-margin,my2))};
          if(!tooCloseToExisting(q2, pts, minSegGap)) pts.push(q2);
        }
      }
    }
    pts.push({x:W-margin, y:H*0.5});
    function pathLength(ps){ let L=0; for(let i=1;i<ps.length;i++) L+=Math.hypot(ps[i].x-ps[i-1].x, ps[i].y-ps[i-1].y); return L; }
    let L=pathLength(pts);
    const targetMin=W*1.45, targetMax=W*1.6;
    let guard=0;
    while(L<targetMin && guard<6){
      guard++;
      const idx=2+Math.floor(Math.random()*(pts.length-4));
      let p={x:(pts[idx-1].x+pts[idx].x)/2 + (Math.random()*40-20),
             y:(pts[idx-1].y+pts[idx].y)/2 + (Math.random()*40-20)};
      if(!tooCloseToExisting(p, pts, 22)){
        pts.splice(idx,0,p);
        L=pathLength(pts);
      }
    }
    guard=0;
    while(L>targetMax && pts.length>30 && guard<6){
      guard++;
      const drop=3+Math.floor(Math.random()*(pts.length-6));
      pts.splice(drop,1);
      L=pathLength(pts);
    }
    return pts;
  }

  function makeVariedDetour(path, startIdx){
    const style = Math.random();
    const anchor = path[startIdx];
    const pts=[{x:anchor.x,y:anchor.y}];
    if(style<0.4){
      const radius = 60 + Math.random()*16;
      const span = Math.PI*(1.0 + Math.random()*0.5);
      const steps = 14;
      const cx = anchor.x + (Math.random()*30-15);
      const cy = anchor.y + (Math.random()*30-15);
      const startA = Math.random()*Math.PI*2;
      for(let i=1;i<=steps;i++){
        const a = startA + span*(i/steps);
        pts.push({x: cx + Math.cos(a)*radius, y: cy + Math.sin(a)*radius});
      }
    }else if(style<0.75){
      const radius = 46 + Math.random()*14;
      const steps = 10;
      const dx = (Math.random()<0.5?-1:1)*(30+Math.random()*20);
      const dy = (Math.random()<0.5?-1:1)*(20+Math.random()*20);
      for(let i=1;i<=steps;i++){
        const t=i/steps;
        const a = Math.sin(t*Math.PI)*Math.PI*0.9;
        pts.push({x: anchor.x + dx*t + Math.cos(a)*radius*0.5, y: anchor.y + Math.sin(a)*radius});
      }
    }else{
      const bump = 32 + Math.random()*18;
      const steps = 12;
      for(let i=1;i<=steps;i++){
        const t=i/steps;
        const a=t*Math.PI*2;
        pts.push({x: anchor.x + Math.cos(a)*bump*0.7, y: anchor.y + Math.sin(a)*bump});
      }
    }
    const rejoinIdx = Math.min(path.length-1, startIdx+4);
    pts.push(path[rejoinIdx]);
    return {points:pts, rejoinIdx};
  }

  const ENEMY={
    virus:{hp:30, spd:110, reward:9, r:9, color:'#6ec1ff'},
    bacteria:{hp:60, spd:55, reward:10, r:11, color:'#86e3a6'},
    fungus:{hp:110, spd:45, reward:14, r:12, color:'#c7a6ff'},
    protozoa:{hp:85, spd:85, reward:16, r:11, color:'#ffb3a6'},
    helminth:{hp:220, spd:38, reward:22, r:13, color:'#ffd166'},
    intracellular:{hp:95, spd:115, reward:20, r:10, color:'#9ae6b4'}
  };
  const TOWER={
    COMPLEMENT:{cost:70, range:150, rof:0.85, dmg:4, color:'#9ad8ff', mark:true, synergy:0.6},
    MACRO:{cost:80, range:140, rof:0.65, dmg:18, color:'#7be3b0', bonusVsMarked:0.3},
    INFLAM:{cost:70, range:180, rof:0.7, dmg:2, color:'#ffa8a8', slow:0.5, splash:28},
    ANTIBODY:{cost:90, range:230, rof:0.55, dmg:9, color:'#ffd166', bonusVsMarked:0.6}
  };

  const BOSS_DEF={
    4:{name:'莢膜巨怪', color:'#ff9e3d', shape:'hex', hp:1200, spd:60, r:22, reward:200,
       onTick:(b,dt)=>{ b.spawnCd=(b.spawnCd||0)-dt; if(b.spawnCd<=0){ b.spawnCd=2.2; spawnMinions(3); }}},
    8:{name:'變異風暴', color:'#3ce8ff', shape:'star', hp:1800, spd:80, r:24, reward:320,
       onTick:(b,dt)=>{ b.dashCd=(b.dashCd||0)-dt; if(b.dashCd<=0){ b.dashCd=3.2; b.dashTime=1.0; } if(b.dashTime>0){ b.dashTime-=dt; b.ignoreSlow=true; } else { b.ignoreSlow=false; }}},
    12:{name:'蠕蟲女王', color:'#ff4ddb', shape:'worm', hp:2600, spd:42, r:26, reward:500,
        onTick:(b,dt)=>{ b.shieldCd=(b.shieldCd||0)-dt; if(b.shieldCd<=0){ b.shieldCd=4.0; b.shieldTime=1.2; } if(b.shieldTime>0){ b.shieldTime-=dt; b.shielded=true; } else { b.shielded=false; }}}
  };

  const typeUnlockSchedule = [
    {wave:1, add:[]},
    {wave:3, add:['fungus']},
    {wave:5, add:['protozoa']},
    {wave:7, add:['helminth']},
    {wave:9, add:['intracellular']},
    {wave:11, add:[]}
  ];
  function unlockByWave(w){
    for(const s of typeUnlockSchedule){
      if(s.wave===w){ for(const t of s.add){ if(!state.unlockedTypes.includes(t)) state.unlockedTypes.push(t);} }
    }
  }

  const waves=[];
  for(let w=1; w<=12; w++){
    unlockByWave(w);
    const pack=[];
    const countBase = 7 + Math.floor(w*1.2);
    const types = [...state.unlockedTypes];
    if(w===4 || w===8 || w===12){
      for(let i=0;i<Math.max(4, Math.floor(countBase*0.5)); i++){
        const t = types[Math.floor(Math.random()*types.length)];
        pack.push({t, at:0.5 + i*0.9});
      }
      pack.push({boss:true, at:2.0});
    }else{
      for(let i=0;i<countBase;i++){
        const t = types[Math.floor(Math.random()*types.length)];
        pack.push({t, at:0.35 + i*0.85});
      }
    }
    waves.push(pack);
  }

  function addCP(v){state.cp=Math.max(0,state.cp+v); ui.cp.textContent = Math.round(state.cp);}

  const buildTools=[...document.querySelectorAll('.tool[data-type]')];
  buildTools.forEach(el=>el.addEventListener('click',()=>{
    buildTools.forEach(x=>x.classList.remove('selected')); el.classList.add('selected');
    placing=el.dataset.type; selected=null;
  }));

  function upgradeCost(t){ return UPGRADE_BASE + UPGRADE_STEP*(t.lvl-1); }
  $('up').addEventListener('click',()=>{
    if(!selected || state.gameOver) return;
    if(selected.lvl>=MAX_LVL) return;
    const cost = upgradeCost(selected);
    if(state.cp<cost) return;
    addCP(-cost);
    selected.lvl++;
    selected.dmg*=1.2; selected.rof*=1.12; selected.range*=1.08;
  });
  $('sell').addEventListener('click',()=>{
    if(!selected || state.gameOver) return;
    const node=state.nodes.find(n=>n.id===selected.nodeId);
    const base=TOWER[selected.kind].cost;
    addCP(Math.floor(base*0.6 + (selected.lvl-1)*18));
    state.towers=state.towers.filter(t=>t!==selected);
    if(node) node.tower=null; selected=null;
  });

  $('swell').addEventListener('click',()=>{
    const now=performance.now()/1000;
    if(state.cp<50 || state.gameOver) return;
    if(now < state.ability.swellCdUntil) return;
    let node=null;
    if(selected){ node=state.nodes.find(n=>n.id===selected.nodeId) || state.nodes.find(n=>n.tower===selected); }
    if(!node) node=state.nodes[Math.floor(state.nodes.length/2)];
    if(node.gate.cdUntil>now) return;
    node.gate.activeUntil = now + 12;
    node.gate.cdUntil = now + state.ability.swellCdDur;
    state.ability.swellCdUntil = now + state.ability.swellCdDur;
    addCP(-50);
  });

  $('chaser').addEventListener('click',()=>{
    const now=performance.now()/1000;
    if(state.cp<60 || state.gameOver) return;
    if(now < state.ability.chaserCdUntil) return;
    let startPos=null;
    if(selected){
      const node=state.nodes.find(n=>n.id===selected.nodeId) || state.nodes.find(n=>n.tower===selected);
      if(node) startPos={x:node.x, y:node.y};
    }
    if(!startPos){ const n=state.nodes[Math.floor(state.nodes.length/2)] || {x:W*0.5,y:H*0.5}; startPos={x:n.x, y:n.y}; }
    state.chasers.push({x:startPos.x,y:startPos.y, vx:0, vy:0, spd:240, dmg:22, r:9, life:10.0, atkCd:0, turn:7.5, glow:0});
    state.ability.chaserCdUntil = now + state.ability.chaserCdDur;
    addCP(-60);
  });

  cnv.addEventListener('click',(ev)=>{
    if(state.gameOver) return;
    const rect=cnv.getBoundingClientRect();
    const mx=(ev.clientX-rect.left)*(cnv.width/rect.width);
    const my=(ev.clientY-rect.top)*(cnv.height/rect.height);
    let hit=null;
    for(const n of state.nodes){ if(Math.hypot(n.x-mx, n.y-my)<=n.r){ hit=n; break; } }
    if(hit){
      if(placing){ build(hit, placing); }
      else { selected = hit.tower || null; }
      return;
    }
    selected=null;
  });

  function build(node, kind){
    if(node.tower) { selected=node.tower; return; }
    const data={...TOWER[kind]};
    if(state.cp<data.cost) return;
    addCP(-data.cost);
    const t={kind, x:node.x, y:node.y, range:data.range, rof:data.rof, dmg:data.dmg, cd:0, lvl:1, color:data.color, nodeId:node.id};
    if(kind==='COMPLEMENT'){ t.mark=true; t.synergy=data.synergy; }
    if(kind==='MACRO'){ t.bonusVsMarked=data.bonusVsMarked; }
    if(kind==='INFLAM'){ t.slow=data.slow; t.splash=data.splash; }
    if(kind==='ANTIBODY'){ t.bonusVsMarked=data.bonusVsMarked; }
    node.tower=t; state.towers.push(t); selected=t;
  }

  function startWave(){
    if(state.wave>=state.wmax || state.gameOver) return;
    if(state.enemies.length===0 && state.queue.length===0){
      state.basePath = generateMixedPath();
      for(const n of state.nodes){
        const idx = nearestPathIdx(n, state.basePath);
        n.gate.startIdx = idx;
        n.gate.loop = makeVariedDetour(state.basePath, idx);
        n.gate.activeUntil = 0;
      }
    }
    state.wave++; ui.wave.textContent=state.wave;

    if(state.wave===4 || state.wave===8 || state.wave===12){
      addNewStations(2);
      flashToast('新增 2 個站點！');
    }

    state.queue.length=0;
    const pack=waves[state.wave-1];
    for(const s of pack) state.queue.push({t:s.t, boss:!!s.boss, at:state.time+s.at});
  }

  function addNewStations(k){
    const margin=50, minDist=100; let tries=0;
    while(k>0 && tries<800){
      tries++;
      const x = margin + Math.random()*(W-2*margin);
      const y = margin + Math.random()*(H-2*margin);
      let ok=true;
      for(const n of state.nodes){
        if(Math.hypot(n.x-x, n.y-y) < minDist){ ok=false; break; }
      }
      if(ok){
        const id = state.nodes.length;
        const node={id, x, y, r:24, tower:null, gate:{startIdx:0, loop:null, activeUntil:0, cdUntil:0}};
        state.nodes.push(node);
        k--;
      }
    }
  }

  function flashToast(msg){
    const d=document.createElement('div');
    d.textContent=msg;
    d.style.position='absolute'; d.style.left='50%'; d.style.top='10px'; d.style.transform='translateX(-50%)';
    d.style.background='rgba(0,0,0,.6)'; d.style.border='1px solid #335'; d.style.padding='8px 12px'; d.style.borderRadius='10px';
    d.style.color='#fff'; d.style.zIndex='9'; d.style.pointerEvents='none';
    document.getElementById('gamebox').appendChild(d);
    setTimeout(()=>{ d.style.transition='opacity .6s'; d.style.opacity='0'; setTimeout(()=>d.remove(),600); }, 1200);
  }

  function drawPath(points){
    if(points.length<3) return;
    const penult=points[points.length-2], lastp=points[points.length-1];
    ctx.strokeStyle='#134f7a'; ctx.lineWidth=26; ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
    for(let i=1;i<points.length-2;i++){
      const xc=(points[i].x + points[i+1].x)/2, yc=(points[i].y + points[i+1].y)/2;
      ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
    }
    ctx.quadraticCurveTo(penult.x, penult.y, lastp.x, lastp.y); ctx.stroke();
    ctx.strokeStyle='rgba(123,227,176,0.35)'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
    for(let i=1;i<points.length-2;i++){
      const xc=(points[i].x + points[i+1].x)/2, yc=(points[i].y + points[i+1].y)/2;
      ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
    }
    ctx.quadraticCurveTo(penult.x, penult.y, lastp.x, lastp.y); ctx.stroke();
  }

  function stepEnemy(e,dt){
    if(state.gameOver) return;
    const now=performance.now()/1000;
    if(e.boss && e.onTick) e.onTick(e,dt);
    const upcomingIdx = e.subpath ? -1 : e.wp;
    if(upcomingIdx>=0){
      const nd = state.nodes.find(n=>n.gate.startIdx===upcomingIdx);
      if(nd && nd.gate.activeUntil>now){
        e.subpath = nd.gate.loop.points.slice(); e.subWp = 1;
      }
    }
    if(e.subpath){
      const target=e.subpath[e.subWp];
      if(!target){
        const nd=state.nodes.find(n=>n.gate.loop && n.gate.loop.points===e.subpath);
        const rejoinIdx = nd? nd.gate.rejoinIdx : (e.wp+1);
        e.subpath=null; e.subWp=0; e.wp = Math.max(e.wp, rejoinIdx);
      }else{
        moveTowards(e, target, dt);
        if(Math.hypot(target.x-e.x, target.y-e.y)<2){ e.subWp++; }
      }
      return;
    }
    const target = state.basePath[e.wp];
    if(!target){
      // 只有「逃出」才扣命
      e.dead=true; e.wp = state.basePath.length;
      state.lives--; ui.lives.textContent=state.lives;
      if(state.lives<=0) state.gameOver=true;
      return;
    }
    moveTowards(e, target, dt);
    if(Math.hypot(target.x-e.x, target.y-e.y)<2){ e.wp++; }
  }
  function moveTowards(e, target, dt){
    const dx=target.x-e.x, dy=target.y-e.y; const d=Math.hypot(dx,dy)||1;
    let sp=e.spd*(1 - Math.min(0.6, e.slow));
    if(e.boss && e.ignoreSlow) sp=e.spd*(1.6);
    e.x += (dx/d)*sp*dt; e.y += (dy/d)*sp*dt;
    e.slow=Math.max(0, e.slow - dt*0.8);
  }

  function stepTower(t,dt){
    if(state.gameOver) return;
    t.cd=Math.max(0,t.cd-dt);
    let target=null, best=1e9;
    for(const e of state.enemies){
      if(e.dead) continue;
      const d=Math.hypot(t.x-e.x, t.y-e.y);
      if(d<=t.range && d<best){ best=d; target=e; }
    }
    if(target && t.cd<=0){
      fire(t,target);
      t.cd=1/t.rof;
    }
  }
  function fire(t,e){
    const baseSp = (t.kind==='ANTIBODY')? 180 : (t.kind==='INFLAM'?240:230);
    const ang=Math.atan2(e.y-t.y, e.x-t.x);
    const p={x:t.x,y:t.y, vx:Math.cos(ang)*baseSp, vy:Math.sin(ang)*baseSp,
             dmg:t.dmg, kind:t.kind, life:3.0, bonus:t.bonusVsMarked||0,
             mark:!!t.mark, slow:t.slow||0, splash:t.splash||0, synergy:t.synergy||0};
    if(t.kind==='ANTIBODY'){ p.homing=true; p.target=e; p.turn=6.0; }
    state.projs.push(p);
  }
  function stepProj(p,dt){
    if(state.gameOver) return;
    if(p.homing){
      if(!p.target || p.target.dead){
        let nearest=null, best=1e9;
        for(const e of state.enemies){
          if(e.dead) continue;
          const d=Math.hypot(p.x-e.x, p.y-e.y);
          if(d<best){ best=d; nearest=e; }
        }
        p.target=nearest;
      }
      if(p.target){
        const desiredAng=Math.atan2(p.target.y-p.y, p.target.x-p.x);
        const curAng=Math.atan2(p.vy, p.vx);
        let diff = desiredAng - curAng;
        while(diff>Math.PI) diff-=2*Math.PI;
        while(diff<-Math.PI) diff+=2*Math.PI;
        const maxTurn=(p.turn||6)*dt;
        const newAng = curAng + Math.max(-maxTurn, Math.min(maxTurn, diff));
        const speed = Math.hypot(p.vx,p.vy);
        p.vx=Math.cos(newAng)*speed; p.vy=Math.sin(newAng)*speed;
      }
    }
    p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt;
    for(const e of state.enemies){
      if(e.dead) continue;
      const hitR = (p.kind==='ANTIBODY' || p.kind==='MACRO')? (e.r+6) : (e.r+4);
      if(Math.hypot(p.x-e.x, p.y-e.y) < hitR){
        applyHit(e, p);
        if(p.kind==='INFLAM' && p.splash){
          for(const e2 of state.enemies){
            if(e2===e || e2.dead) continue;
            if(Math.hypot(p.x-e2.x, p.y-e2.y) <= p.splash){ applyHit(e2, p, true); }
          }
        }
        state.crumb.push({x:e.x,y:e.y,life:0.18});
        p.life=0;
      }
    }
  }
  function applyHit(target, p, splash=false){
    let dmg=p.dmg;
    if(target.boss && target.shielded) dmg *= 0.5;
    if(p.kind==='MACRO' && target.marked) dmg *= (1 + (p.bonus||0.3));
    if(p.kind==='ANTIBODY' && target.marked) dmg *= (1 + (p.bonus||0.6));
    if(p.kind==='COMPLEMENT') target.marked=true;
    if(p.slow && !target.ignoreSlow) target.slow=Math.max(target.slow, splash? p.slow*0.8 : p.slow);
    target.hp -= dmg;
    if(target.hp<=0){
      target.dead=true; target.wp = state.basePath.length;
      const waveMul = 1 + (state.wave-1)*0.5;
      const base = (target.boss ? BOSS_DEF[state.wave].reward : (target.reward||10));
      addCP(Math.round(base * waveMul));
      if(target.boss && state.wave===12){ spawnMinions(6); }
    }
  }

  function spawnMinions(n){
    for(let i=0;i<n;i++){
      const t = (Math.random()<0.5)?'virus':'bacteria';
      const base = state.basePath[0] || {x:10,y:H*0.5};
      state.enemies.push({type:t, x:base.x, y:base.y, wp:1, hp:ENEMY[t].hp, maxhp:ENEMY[t].hp, spd:ENEMY[t].spd, r:ENEMY[t].r, color:ENEMY[t].color, reward:ENEMY[t].reward, marked:false, slow:0, dead:false, subpath:null, subWp:0});
    }
  }

  function draw(){
    ctx.fillStyle='#081224'; ctx.fillRect(0,0,W,H);
    if(state.basePath.length>1) drawPath(state.basePath);
    for(const n of state.nodes){
      const loop=n.gate.loop? n.gate.loop.points : null;
      if(loop){
        ctx.strokeStyle='rgba(255,209,102,0.25)'; ctx.lineWidth=8;
        ctx.beginPath(); ctx.moveTo(loop[0].x, loop[0].y);
        for(let i=1;i<loop.length;i++){
          const prev=loop[i-1], cur=loop[i];
          const midx=(prev.x+cur.x)/2, midy=(prev.y+cur.y)/2;
          ctx.quadraticCurveTo(prev.x, prev.y, midx, midy);
        } ctx.stroke();
      }
      ctx.fillStyle='#0d2c54'; ctx.beginPath(); ctx.arc(n.x,n.y,n.r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#2a5d9a'; ctx.lineWidth=2; ctx.stroke();
      if(n.tower){
        const t=n.tower;
        ctx.fillStyle=t.color; ctx.beginPath(); ctx.arc(n.x,n.y,12,0,Math.PI*2); ctx.fill();
        if(selected===t){
          ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(t.x,t.y,t.range,0,Math.PI*2); ctx.stroke();
        }
      }
    }
    for(const e of state.enemies){
      if(e.dead) continue;
      const ratio=e.hp/e.maxhp;
      if(e.boss){
        ctx.save(); ctx.translate(e.x, e.y);
        ctx.fillStyle=e.color; ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=2;
        ctx.beginPath(); for(let i=0;i<6;i++){ const a=i*Math.PI/3; const r=e.r+6; const x=Math.cos(a)*r, y=Math.sin(a)*r; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
        ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
      }else{
        ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();
      }
      ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(e.x,e.y,(e.boss? e.r+10: e.r+3),-Math.PI/2,-Math.PI/2+Math.PI*2*ratio); ctx.stroke();
      if(e.marked){ ctx.strokeStyle='rgba(255,230,140,.9)'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(e.x,e.y,(e.boss? e.r+14: e.r+6),0,Math.PI*2); ctx.stroke(); }
    }
    for(const p of state.projs){
      const isAB = (p.kind==='ANTIBODY');
      ctx.fillStyle = isAB ? '#ffe08a' : (p.kind==='INFLAM' ? '#ffa8a8' : (p.kind==='COMPLEMENT' ? '#9ad8ff' : '#7be3b0'));
      ctx.beginPath(); ctx.arc(p.x,p.y, isAB?5:4,0,Math.PI*2); ctx.fill();
      if(p.kind==='INFLAM' && p.splash){ ctx.globalAlpha=0.15; ctx.beginPath(); ctx.arc(p.x,p.y,p.splash,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
    }
    for(const c of state.chasers){ if(c.life>0) drawChaser(c); }
    for(const c of state.crumb){
      ctx.globalAlpha=Math.max(0,c.life/0.18);
      ctx.fillStyle='#fff'; ctx.fillRect(c.x-1,c.y-1,2,2);
      ctx.globalAlpha=1;
    }
    const now=performance.now()/1000;
    if(state.ability.swellCdUntil > now){
      const remain = state.ability.swellCdUntil - now;
      cdSwell.style.width = (Math.max(0,Math.min(1, remain / state.ability.swellCdDur))*100).toFixed(1)+'%';
    }else{ cdSwell.style.width = '0%'; }
    if(state.ability.chaserCdUntil > now){
      const remain = state.ability.chaserCdUntil - now;
      cdChaser.style.width = (Math.max(0,Math.min(1, remain / state.ability.chaserCdDur))*100).toFixed(1)+'%';
    }else{ cdChaser.style.width = '0%'; }

    if(state.gameOver){
      ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.font='28px sans-serif';
      const text='敗北！淋巴防線被突破'; const tw=ctx.measureText(text).width; ctx.fillText(text,(W-tw)/2,H/2);
    }
    if(state.victory){
      ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#7be3b0'; ctx.font='32px sans-serif';
      const text='勝利！成功守住 12 波'; const tw=ctx.measureText(text).width; ctx.fillText(text,(W-tw)/2,H/2);
    }
  }

  function drawChaser(c){
    const ctx=cnv.getContext('2d');
    ctx.save();
    ctx.globalAlpha = 0.85;
    if(c.glow>0){
      ctx.fillStyle='rgba(255,255,255,0.25)';
      ctx.beginPath(); ctx.arc(c.x, c.y, c.r+8, 0, Math.PI*2); ctx.fill();
    }
    ctx.fillStyle='#ffffff';
    ctx.beginPath(); ctx.arc(c.x, c.y, c.r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='rgba(135,206,250,0.9)';
    ctx.beginPath(); ctx.arc(c.x+1.5, c.y+1.5, c.r*0.5, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function updateAutoNext(dt){
    const clear = (state.enemies.length===0 && state.queue.length===0);
    const canNext = (!state.gameOver && !state.victory && state.wave < state.wmax);
    if(state.wave>0 && clear && canNext){
      if(!autoActive){ autoActive=true; autoTimer=10; autoBox.style.display='flex'; autoBar.style.width='0%'; }
      autoTimer -= dt;
      autoBar.style.width = Math.max(0, Math.min(100, (1 - autoTimer/10)*100)).toFixed(1) + '%';
      if(autoTimer<=0){
        startWave();
        autoActive=false; autoBox.style.display='none';
      }
    }else{
      if(autoActive){ autoActive=false; autoBox.style.display='none'; }
    }
  }

  let last=performance.now();
  function loop(ts){
    const dt=Math.min(0.05,(ts-last)/1000); last=ts;
    if(!paused){
      state.time+=dt;
      if(!state.gameOver && !state.victory){
        while(state.queue.length && state.queue[0].at<=state.time){
          const s=state.queue.shift();
          if(s.boss){
            const def=BOSS_DEF[state.wave];
            const base = state.basePath[0] || {x:10,y:H*0.5};
            state.enemies.push({boss:true, name:def.name, x:base.x, y:base.y, wp:1, hp:def.hp, maxhp:def.hp, spd:def.spd, r:def.r, color:def.color,
               reward:def.reward, marked:false, slow:0, dead:false, subpath:null, subWp:0, onTick:def.onTick, ignoreSlow:false, shielded:false, shape:def.shape});
          } else {
            const t=s.t; const base = state.basePath[0] || {x:10,y:H*0.5};
            state.enemies.push({type:t, x:base.x, y:base.y, wp:1, hp:ENEMY[t].hp, maxhp:ENEMY[t].hp, spd:ENEMY[t].spd, r:ENEMY[t].r, color:ENEMY[t].color, reward:ENEMY[t].reward, marked:false, slow:0, dead:false, subpath:null, subWp:0});
          }
        }
        for(const e of state.enemies) stepEnemy(e,dt);
        state.enemies=state.enemies.filter(e=>!e.dead && e.wp<state.basePath.length);
        for(const t of state.towers) stepTower(t,dt);
        for(const p of state.projs) stepProj(p,dt);
        state.projs=state.projs.filter(p=>p.life>0);
        for(const c of state.chasers){ c.life-=dt; }
        state.chasers = state.chasers.filter(c=>c.life>0);

        if(state.wave===state.wmax && state.enemies.length===0 && state.queue.length===0){
          state.victory=true;
        }
      }
    }
    updateAutoNext(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // 正確的按鈕文字：初始為「繼續」（因為 paused=true）
  btn.pause.textContent='繼續';
  btn.pause.addEventListener('click',()=>{
    if(state.gameOver || state.victory) return;
    paused=!paused; btn.pause.textContent=paused?'繼續':'暫停';
    if(!paused && state.wave===0){
      // 初次切到繼續 → 啟動首波
      if(state.basePath.length===0){
        state.basePath = generateMixedPath();
        for(const n of state.nodes){
          const idx = nearestPathIdx(n, state.basePath);
          n.gate.startIdx=idx; n.gate.loop = makeVariedDetour(state.basePath, idx);
        }
      }
      startWave();
    }
  });

  // 初始先生成路徑讓玩家部署時可參考
  state.basePath = generateMixedPath();
  for(const n of state.nodes){
    const idx = nearestPathIdx(n, state.basePath);
    n.gate.startIdx=idx; n.gate.loop = makeVariedDetour(state.basePath, idx);
  }

  requestAnimationFrame(loop);
  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space'){
      e.preventDefault();
      if(!state.gameOver && !state.victory){
        paused=!paused; btn.pause.textContent=paused?'繼續':'暫停';
        if(!paused && state.wave===0){
          if(state.basePath.length===0){
            state.basePath = generateMixedPath();
            for(const n of state.nodes){
              const idx = nearestPathIdx(n, state.basePath);
              n.gate.startIdx=idx; n.gate.loop = makeVariedDetour(state.basePath, idx);
            }
          }
          startWave();
        }
      }
    }
  }, {passive:false});
  window.addEventListener('blur', ()=>{ if(!state.gameOver && !state.victory){ paused=true; btn.pause.textContent='繼續'; } });
})();
</script>
</body>
</html>
