<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>淋巴守城：教學完善＋路徑約1.5×</title>
<style>
  :root{--bg:#0b1020; --panel:#101935; --text:#eaf1ff; --acc:#7be3b0; --warn:#ffd166; --danger:#ff6b6b;}
  *{box-sizing:border-box; font-family: system-ui, -apple-system, "Noto Sans TC", "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body{margin:0; background:linear-gradient(180deg,#0b1020 0%, #0f1a3a 100%); color:var(--text);}
  header{display:flex;align-items:center;gap:.6rem; padding:.7rem 1rem; background:#0d1633; position:sticky; top:0; z-index:5; box-shadow:0 2px 8px rgba(0,0,0,.4)}
  .stat{padding:.35rem .6rem; border:1px solid #1f2b55; border-radius:10px; background:#0f1a3a; font-weight:700}
  header button{appearance:none;border:none;border-radius:10px; padding:.55rem .8rem; background:#1a3568; color:#d8e8ff; cursor:pointer; position:relative; overflow:hidden}
  header button:hover{background:#23457f}
  #wrap{display:grid; grid-template-columns:1fr; justify-items:center; padding:10px}
  #gamebox{position:relative; width:min(1100px,96vw); aspect-ratio:16/9; background:#081224; border:1px solid #1a2a54; border-radius:16px; overflow:hidden; box-shadow:0 6px 24px rgba(0,0,0,.5)}
  canvas{width:100%; height:100%; display:block}
  #panel{display:flex;gap:.6rem;flex-wrap:wrap; padding:8px 0}
  .tool{display:flex;align-items:center;gap:.4rem; padding:.5rem .7rem; border:1px solid #2a3c74; border-radius:10px; background:#0f1c3d; cursor:pointer; position:relative; overflow:hidden}
  .tool strong{letter-spacing:.5px}
  .tool .cost{opacity:.85}
  .selected{outline:2px solid var(--acc)}
  /* Tutorial modal */
  #modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.55); z-index:20}
  #modal .card{width:min(880px,94vw); max-height:90vh; overflow:auto; background:#0f1a3a; border:1px solid #294079; border-radius:14px; padding:16px 18px; box-shadow:0 8px 28px rgba(0,0,0,.5)}
  #modal h2{margin:0 0 8px 0; font-size:20px}
  #modal h3{margin:18px 0 6px 0; font-size:17px; color:#bfe3ff}
  #modal p, #modal li{line-height:1.6}
  #modal .actions{display:flex; justify-content:flex-end; gap:8px; margin-top:8px}
  #modal button{background:#1a3568; border:1px solid #294079; color:#fff; border-radius:10px; padding:.45rem .8rem; cursor:pointer}
  #modal button:hover{background:#23457f}
  .cdbar{position:absolute; left:0; top:0; height:100%; width:0%; background:rgba(255,255,255,0.18); pointer-events:none; transition:width .1s linear}
  footer{display:none}
</style>
</head>
<body>
<header>
  <div class="stat">CP：<span id="cp">0</span></div>
  <div class="stat">Wave：<span id="wave">0</span>/<span id="wmax">12</span></div>
  <div class="stat">Lives：<span id="lives">15</span></div>
  <button id="start">開始</button>
  <button id="next">下一波</button>
  <button id="pause">暫停</button>
  <button id="help">教學</button>
</header>

<div id="wrap">
  <div id="gamebox">
    <canvas id="game" width="1152" height="648"></canvas>
  </div>
  <div id="panel">
    <div class="tool" data-type="COMPLEMENT"><span class="cdbar"></span><strong>補體系統</strong><span class="cost">CP 70</span><span>（貼標＋輕傷）</span></div>
    <div class="tool" data-type="MACRO"><span class="cdbar"></span><strong>巨噬細胞</strong><span class="cost">CP 80</span><span>（單體高傷）</span></div>
    <div class="tool" data-type="INFLAM"><span class="cdbar"></span><strong>發炎介質</strong><span class="cost">CP 70</span><span>（範圍減速）</span></div>
    <div class="tool" data-type="ANTIBODY"><span class="cdbar"></span><strong>抗體</strong><span class="cost">CP 90</span><span>（追蹤強擊）</span></div>
    <div class="tool" id="up"><span class="cdbar"></span><strong>升級</strong><span class="cost">CP 60</span></div>
    <div class="tool" id="sell"><span class="cdbar"></span><strong>出售</strong><span class="cost">返還60%</span></div>
    <div class="tool" id="swell"><span class="cdbar" id="cd_swell"></span><strong>淋巴結腫大</strong><span class="cost">CP 50</span><span>（繞路12s / 冷卻20s）</span></div>
    <div class="tool" id="chaser"><span class="cdbar" id="cd_chaser"></span><strong>追擊淋巴球（IL‑2）</strong><span class="cost">CP 60</span><span>（10s / 冷卻15s）</span></div>
  </div>
</div>

<!-- Tutorial Modal -->
<div id="modal">
  <div class="card">
    <h2>遊戲教學</h2>
    <h3>基本規則</h3>
    <ul>
      <li><b>第一波</b>：按「開始」才會出怪，<b>首波路線固定</b>。</li>
      <li><b>第二波起</b>：每波開始前會<b>重新生成淋巴管路線</b>，並<b>必經畫面中央</b>，總長度約為<b>畫面寬度的 1.5 倍</b>（含彎曲/回環）。</li>
      <li><b>站點</b>：首波前有 <b>6 個</b>建塔站點，<b>每遇到 Boss（第 4、8、12 波）自動新增 2 個</b>站點。</li>
      <li><b>CP</b>：僅在<b>擊殺病原體</b>時獲得；越後面波數擊殺獎勵越高。初始 CP = <b>180</b>。</li>
      <li><b>勝負</b>：病原體到達終點會扣生命值，生命值歸零則失敗；清完 12 波即勝利。</li>
    </ul>

    <h3>塔（免疫機制）</h3>
    <ul>
      <li><b>補體系統</b>（CP 70）：對敵造成小傷，並<b>貼標</b>（opsonization），讓其他塔打更痛。</li>
      <li><b>巨噬細胞</b>（CP 80）：<b>單體高傷</b>，對<b>已貼標</b>目標有額外加成。</li>
      <li><b>發炎介質</b>（CP 70）：<b>範圍減速</b>＋小傷，製造局部發炎讓敵人移動變慢。</li>
      <li><b>抗體</b>（CP 90）：<b>追蹤彈</b>、高射程，對<b>已貼標</b>目標更痛，但射速較慢。</li>
      <li><b>升級</b>（CP 60）：強化所選塔的傷害、射速、射程。</li>
      <li><b>出售</b>：返還 60% 成本＋少量等級補償。</li>
    </ul>

    <h3>技能</h3>
    <ul>
      <li><b>淋巴結腫大</b>（CP 50）：在某站點觸發<b>12 秒繞路</b>，使路線更像迷宮；<b>冷卻 20 秒</b>。按鈕上會出現<b>半透明冷卻條</b>。</li>
      <li><b>追擊淋巴球（IL‑2）</b>（CP 60）：召喚追擊單位<b>10 秒</b>；<b>冷卻 15 秒</b>，按鈕有<b>冷卻條</b>。</li>
    </ul>

    <h3>敵人種類與特性</h3>
    <ul>
      <li><b>一般波</b>：
        <ul>
          <li><b>病毒</b>：移速快、血量低。</li>
          <li><b>細菌</b>：中速、血量中等。</li>
          <li><b>真菌</b>（第 3 波起）：血較厚、偏慢。</li>
          <li><b>原蟲</b>（第 5 波起）：偏快、靈活。</li>
          <li><b>蠕蟲</b>（第 7 波起）：<b>高血量</b>、很慢。</li>
          <li><b>細胞內型</b>（第 9 波起）：<b>很快</b>、血量中。</li>
        </ul>
      </li>
      <li><b>Boss 波</b>（第 4／8／12 波，外觀與技能各不同）
        <ul>
          <li><b>第 4 波：莢膜巨怪</b>（六角形，橙色）—<b>週期召喚</b>小兵。</li>
          <li><b>第 8 波：變異風暴</b>（星形，亮青）—<b>衝刺</b>短暫無視減速。</li>
          <li><b>第 12 波：蠕蟲女王</b>（分節，洋紅）—<b>護盾</b>週期減傷，死亡時<b>噴出幼體</b>。</li>
        </ul>
      </li>
    </ul>

    <div class="actions">
      <button id="closeModal">關閉</button>
    </div>
  </div>
</div>

<script>
(()=>{
  function $(id){return document.getElementById(id);}
  const W=1152,H=648;
  const cnv=$('game'); const ctx=cnv.getContext('2d');
  const ui={cp:$('cp'), wave:$('wave'), lives:$('lives')};
  const btn={start:$('start'), next:$('next'), pause:$('pause'), help:$('help')};
  const toolEls=[...document.querySelectorAll('.tool[data-type]')];
  const swellEl=$('swell'), chaserEl=$('chaser');
  const cdSwell=$('cd_swell'), cdChaser=$('cd_chaser');
  const modal=$('modal'); const closeModal=$('closeModal');
  let placing=null, selected=null, paused=false, started=false, nextReady=false;

  const state={
    cp:250, lives:15, wave:0, wmax:12, time:0,
    basePath:[], enemies:[], towers:[], projs:[], crumb:[], queue:[],
    nodes:[], chasers:[],
    ability:{ swellCdDur:20, swellCdUntil:0, chaserCdDur:15, chaserCdUntil:0 },
    nodeIndices:[], // dynamic
    unlockedTypes:['virus','bacteria'],
  };
  ui.cp.textContent=state.cp; ui.wave.textContent=state.wave; ui.lives.textContent=state.lives;

  // ---- geometry helpers ----
  function pathLength(pts){
    let L=0;
    for(let i=1;i<pts.length;i++){ const dx=pts[i].x-pts[i-1].x, dy=pts[i].y-pts[i-1].y; L+=Math.hypot(dx,dy); }
    return L;
  }
  function pointAt(pts, idx){ return pts[Math.max(0, Math.min(pts.length-1, idx))]; }

  // ---- PATH (~1.5× width, center pass, allow small loops) ----
  function makeRandomWinding(){
    const targetLenMin = W*1.45, targetLenMax = W*1.6;
    for(let attempt=0; attempt<50; attempt++){
      const pts=[];
      const baseCount=28;
      const ph1 = Math.random()*Math.PI*2;
      const ph2 = Math.random()*Math.PI*2;
      const amp1=75+Math.random()*35, amp2=35+Math.random()*25;
      const centerY = H*0.5 + (Math.random()*20-10);
      for(let i=0;i<baseCount;i++){
        const t=i/(baseCount-1);
        const x=30 + t*(W-60);
        let y=centerY + Math.sin(i*0.6+ph1)*amp1 + Math.sin(i*1.25+ph2)*amp2;
        y=Math.max(70, Math.min(H-70, y));
        pts.push({x,y});
      }
      // must-pass middle anchors
      const force=[{i:7,y:centerY+(Math.random()*40-20)},{i:14,y:centerY+(Math.random()*20-10)},{i:21,y:centerY+(Math.random()*40-20)}];
      for(const f of force){ if(pts[f.i]) pts[f.i].y=f.y; }
      // 1~2 mild loopbacks
      const loops = 1 + Math.floor(Math.random()*2);
      for(let k=0;k<loops;k++){
        const idx = 5 + Math.floor(Math.random()*16);
        const anchor = pts[idx];
        const rad = 55 + Math.random()*22;
        const span = Math.PI*(1.5 + Math.random()*0.4);
        const steps=10;
        const startA = Math.random()*Math.PI*2;
        const cx = anchor.x + (Math.random()*50-25);
        const cy = anchor.y + (Math.random()*50-25);
        const loopPts=[{x:anchor.x,y:anchor.y}];
        for(let s=1;s<=steps;s++){
          const a=startA + span*(s/steps);
          loopPts.push({x:cx+Math.cos(a)*rad, y:cy+Math.sin(a)*rad});
        }
        pts.splice(idx+1,0,...loopPts);
      }
      const L=pathLength(pts);
      if(L>=targetLenMin && L<=targetLenMax) return pts;
    }
    // fallback close to 1.5×
    return basicSinePath();
  }

  function basicSinePath(){
    const pts=[]; const count=26; const centerY=H*0.5;
    for(let i=0;i<count;i++){
      const t=i/(count-1);
      const x=30+t*(W-60);
      const y=centerY+Math.sin(i*0.7)*90+Math.sin(i*1.2)*40;
      pts.push({x, y});
    }
    return pts;
  }

  // ---- Nodes ----
  function computeInitialNodeIndices(k){
    const n = state.basePath.length;
    const idxs=[];
    for(let i=1;i<=k;i++){
      const idx = Math.floor(i*(n-2)/(k+1)); // spread along path (avoid endpoints)
      idxs.push(Math.max(1, Math.min(n-3, idx)));
    }
    return idxs;
  }
  function addNewNodeIndices(k){
    const n = state.basePath.length;
    const newIdxs=[];
    let tries=0;
    while(newIdxs.length<k && tries<200){
      tries++;
      const idx = 2 + Math.floor(Math.random()*(n-4));
      const ok = state.nodeIndices.every(j=>Math.abs(j-idx)>2) && newIdxs.every(j=>Math.abs(j-idx)>2);
      if(ok){ newIdxs.push(idx); }
    }
    state.nodeIndices.push(...newIdxs.sort((a,b)=>a-b));
  }
  function rebuildNodesAndLoops(){
    const newNodes = state.nodeIndices.map((pathIdx,i)=>{
      const p=pointAt(state.basePath, pathIdx);
      const nx=p.x + (Math.random()*12-6);
      const ny=p.y - (60 + Math.random()*18);
      const old = state.nodes.find(n=>n.id===i);
      const node={id:i, x:nx, y:ny, r:24, tower: old? old.tower : null,
                  gate:{startIdx:Math.min(pathIdx, state.basePath.length-2), loop:makeArcDetour(Math.min(pathIdx, state.basePath.length-2)), activeUntil:0, cdUntil:0}};
      if(node.tower){ node.tower.x=nx; node.tower.y=ny; node.tower.nodeId=i; }
      return node;
    });
    state.nodes = newNodes;
  }
  function makeArcDetour(startIdx){
    const anchor = state.basePath[startIdx];
    const radius = 70 + Math.random()*18;
    const span = Math.PI * (1.6 + Math.random()*0.35);
    const steps = 16;
    const cx = anchor.x - 8 + (Math.random()*16-8);
    const cy = anchor.y - 35 + (Math.random()*14-7);
    const startAngle = Math.PI*(0.15 + Math.random()*0.2);
    const points = [{x:anchor.x, y:anchor.y}];
    for(let i=1;i<=steps;i++){
      const a = startAngle + (span*i/steps);
      points.push({x: cx + Math.cos(a)*radius, y: cy + Math.sin(a)*radius});
    }
    const rejoinIdx = Math.min(state.basePath.length-1, startIdx+4);
    points.push(state.basePath[rejoinIdx]);
    return {points, rejoinIdx};
  }

  // Initial path + nodes
  state.basePath = makeRandomWinding();
  state.nodeIndices = computeInitialNodeIndices(6);
  rebuildNodesAndLoops();

  // ---------- ENTITIES & TOWERS ----------
  const ENEMY={
    virus:{hp:30, spd:110, reward:9, r:9, color:'#6ec1ff'},
    bacteria:{hp:60, spd:55, reward:10, r:11, color:'#86e3a6'},
    fungus:{hp:110, spd:45, reward:14, r:12, color:'#c7a6ff'},
    protozoa:{hp:85, spd:85, reward:16, r:11, color:'#ffb3a6'},
    helminth:{hp:220, spd:38, reward:22, r:13, color:'#ffd166'},
    intracellular:{hp:95, spd:115, reward:20, r:10, color:'#9ae6b4'}
  };
  const TOWER={
    COMPLEMENT:{cost:70, range:150, rof:0.85, dmg:4, color:'#9ad8ff', mark:true, synergy:0.6},
    MACRO:{cost:80, range:140, rof:0.65, dmg:18, color:'#7be3b0', bonusVsMarked:0.3},
    INFLAM:{cost:70, range:180, rof:0.7, dmg:2, color:'#ffa8a8', slow:0.5, splash:28},
    ANTIBODY:{cost:90, range:230, rof:0.55, dmg:9, color:'#ffd166', bonusVsMarked:0.6}
  };

  const typeUnlockSchedule = [
    {wave:1, add:[]},
    {wave:3, add:['fungus']},
    {wave:5, add:['protozoa']},
    {wave:7, add:['helminth']},
    {wave:9, add:['intracellular']},
    {wave:11, add:[]}
  ];
  function unlockByWave(w){
    for(const s of typeUnlockSchedule){
      if(s.wave===w){ for(const t of s.add){ if(!state.unlockedTypes.includes(t)) state.unlockedTypes.push(t);} }
    }
  }

  const BOSS_DEF={
    4:{name:'莢膜巨怪', color:'#ff9e3d', shape:'hex', hp:1200, spd:60, r:22, reward:200,
       onTick:(b,dt)=>{ b.spawnCd=(b.spawnCd||0)-dt; if(b.spawnCd<=0){ b.spawnCd=2.2; spawnMinions(3); }}},
    8:{name:'變異風暴', color:'#3ce8ff', shape:'star', hp:1800, spd:80, r:24, reward:320,
       onTick:(b,dt)=>{ b.dashCd=(b.dashCd||0)-dt; if(b.dashCd<=0){ b.dashCd=3.2; b.dashTime=1.0; } if(b.dashTime>0){ b.dashTime-=dt; b.ignoreSlow=true; } else { b.ignoreSlow=false; }}},
    12:{name:'蠕蟲女王', color:'#ff4ddb', shape:'worm', hp:2600, spd:42, r:26, reward:500,
        onTick:(b,dt)=>{ b.shieldCd=(b.shieldCd||0)-dt; if(b.shieldCd<=0){ b.shieldCd=4.0; b.shieldTime=1.2; } if(b.shieldTime>0){ b.shieldTime-=dt; b.shielded=true; } else { b.shielded=false; }}}
  };

  // Waves
  const waves=[];
  for(let w=1; w<=state.wmax; w++){
    unlockByWave(w);
    const pack=[];
    const countBase = 7 + Math.floor(w*1.2);
    const types = [...state.unlockedTypes];
    if(w===4 || w===8 || w===12){
      for(let i=0;i<Math.max(4, Math.floor(countBase*0.5)); i++){
        const t = types[Math.floor(Math.random()*types.length)];
        pack.push({t, at:0.5 + i*0.9});
      }
      pack.push({boss:true, at:2.0});
    }else{
      for(let i=0;i<countBase;i++){
        const t = types[Math.floor(Math.random()*types.length)];
        pack.push({t, at:0.35 + i*0.85});
      }
    }
    waves.push(pack);
  }

  function addCP(v){state.cp=Math.max(0,state.cp+v); ui.cp.textContent = Math.round(state.cp);}

  // Tool select
  toolEls.forEach(el=>el.addEventListener('click',()=>{
    toolEls.forEach(x=>x.classList.remove('selected')); el.classList.add('selected');
    placing=el.dataset.type; selected=null;
  }));

  // Upgrade / sell
  $('up').addEventListener('click',()=>{
    if(!selected || state.cp<60) return;
    addCP(-60); selected.lvl++; selected.dmg*=1.2; selected.rof*=1.12; selected.range*=1.08;
  });
  $('sell').addEventListener('click',()=>{
    if(!selected) return;
    const node=state.nodes.find(n=>n.id===selected.nodeId);
    const base=TOWER[selected.kind].cost;
    addCP(Math.floor(base*0.6 + (selected.lvl-1)*18));
    state.towers=state.towers.filter(t=>t!==selected);
    if(node) node.tower=null; selected=null;
  });

  // Skills
  swellEl.addEventListener('click',()=>{
    const now=performance.now()/1000;
    if(state.cp<50) return;
    if(now < state.ability.swellCdUntil) return;
    let node=null;
    if(selected){ node=state.nodes.find(n=>n.id===selected.nodeId) || state.nodes.find(n=>n.tower===selected); }
    if(!node) node=state.nodes[Math.floor(state.nodes.length/2)];
    if(node.gate.cdUntil>now) return;
    node.gate.activeUntil = now + 12;
    node.gate.cdUntil = now + state.ability.swellCdDur;
    state.ability.swellCdUntil = now + state.ability.swellCdDur;
    addCP(-50);
  });

  chaserEl.addEventListener('click',()=>{
    const now=performance.now()/1000;
    if(state.cp<60) return;
    if(now < state.ability.chaserCdUntil) return;
    let startPos=null;
    if(selected){
      const node=state.nodes.find(n=>n.id===selected.nodeId) || state.nodes.find(n=>n.tower===selected);
      if(node) startPos={x:node.x, y:node.y};
    }
    if(!startPos){ const n=state.nodes[Math.floor(state.nodes.length/2)]; startPos={x:n.x, y:n.y}; }
    state.chasers.push({x:startPos.x,y:startPos.y, spd:200, dmg:18, r:8, life:10, cd:0});
    state.ability.chaserCdUntil = now + state.ability.chaserCdDur;
    addCP(-60);
  });

  // Build/select
  cnv.addEventListener('click',(ev)=>{
    const rect=cnv.getBoundingClientRect();
    const mx=(ev.clientX-rect.left)*(cnv.width/rect.width);
    const my=(ev.clientY-rect.top)*(cnv.height/rect.height);
    let hit=null;
    for(const n of state.nodes){ if(Math.hypot(n.x-mx,n.y-my)<=n.r){ hit=n; break; } }
    if(hit){
      if(placing){ build(hit, placing); }
      else { selected = hit.tower || null; }
      return;
    }
    selected=null;
  });

  function build(node, kind){
    if(node.tower) { selected=node.tower; return; }
    const data=TOWER[kind];
    if(state.cp<data.cost) return;
    addCP(-data.cost);
    const t={kind, x:node.x, y:node.y, range:data.range, rof:data.rof, dmg:data.dmg, cd:0, lvl:1, color:data.color, nodeId:node.id};
    if(kind==='COMPLEMENT'){ t.mark=true; t.synergy=TOWER[kind].synergy; }
    if(kind==='MACRO'){ t.bonusVsMarked=TOWER[kind].bonusVsMarked; }
    if(kind==='INFLAM'){ t.slow=TOWER[kind].slow; t.splash=TOWER[kind].splash; }
    if(kind==='ANTIBODY'){ t.bonusVsMarked=TOWER[kind].bonusVsMarked; }
    node.tower=t; state.towers.push(t); selected=t;
  }

  // Wave / Boss logic
  function startWave(){
    if(state.wave>=state.wmax) return;
    if(state.wave>=1){
      state.basePath = makeRandomWinding();
      rebuildNodesAndLoops();
    }
    state.wave++; ui.wave.textContent=state.wave;
    unlockByWave(state.wave);
    if(state.wave===4 || state.wave===8 || state.wave===12){
      addNewNodeIndices(2);
      rebuildNodesAndLoops();
      flashToast('新增 2 個站點！');
    }
    state.queue.length=0;
    const pack=waves[state.wave-1];
    for(const s of pack) state.queue.push({t:s.t, boss:!!s.boss, at:state.time+s.at});
    nextReady=false;
  }

  btn.start.addEventListener('click',()=>{ if(!started){ started=true; startWave(); } });
  btn.next.addEventListener('click',()=>{ if(started) nextReady=true; });
  btn.pause.addEventListener('click',()=>{ paused=!paused; btn.pause.textContent=paused?'繼續':'暫停'; });
  btn.help.addEventListener('click',()=>{ modal.style.display='flex'; });
  closeModal.addEventListener('click',()=>{ modal.style.display='none'; });

  function flashToast(msg){
    const d=document.createElement('div');
    d.textContent=msg;
    d.style.position='absolute'; d.style.left='50%'; d.style.top='10px'; d.style.transform='translateX(-50%)';
    d.style.background='rgba(0,0,0,.6)'; d.style.border='1px solid #335'; d.style.padding='8px 12px'; d.style.borderRadius='10px';
    d.style.color='#fff'; d.style.zIndex='9'; d.style.pointerEvents='none';
    document.getElementById('gamebox').appendChild(d);
    setTimeout(()=>{ d.style.transition='opacity .6s'; d.style.opacity='0'; setTimeout(()=>d.remove(),600); }, 1200);
  }

  // Movement helpers
  function moveTowards(e, target, dt){
    const dx=target.x-e.x, dy=target.y-e.y; const d=Math.hypot(dx,dy)||1;
    let sp=e.spd*(1 - Math.min(0.6, e.slow));
    if(e.boss && e.ignoreSlow) sp=e.spd*(1.6);
    e.x += (dx/d)*sp*dt; e.y += (dy/d)*sp*dt;
    e.slow=Math.max(0, e.slow - dt*0.8);
  }

  function stepEnemy(e,dt){
    const now=performance.now()/1000;
    if(e.boss && e.onTick) e.onTick(e,dt);
    const upcomingIdx = e.subpath ? -1 : e.wp;
    if(upcomingIdx>=0){
      const nd = state.nodes.find(n=>n.gate.startIdx===upcomingIdx);
      if(nd && nd.gate.activeUntil>now){
        e.subpath = nd.gate.loop.points.slice();
        e.subWp = 1;
      }
    }
    if(e.subpath){
      const target=e.subpath[e.subWp];
      if(!target){
        const node=state.nodes.find(n=>n.gate.loop.points===e.subpath);
        const rejoinIdx=node? node.gate.rejoinIdx : (e.wp+1);
        e.subpath=null; e.subWp=0; e.wp = Math.max(e.wp, rejoinIdx);
      }else{
        moveTowards(e, target, dt);
        if(Math.hypot(target.x-e.x, target.y-e.y)<2){ e.subWp++; }
      }
      return;
    }
    const target = state.basePath[e.wp];
    if(!target){
      e.dead=true; state.lives--; ui.lives.textContent=state.lives; return;
    }
    moveTowards(e, target, dt);
    if(Math.hypot(target.x-e.x, target.y-e.y)<2){ e.wp++; }
  }

  // Towers & projectiles
  function stepTower(t,dt){
    t.cd=Math.max(0,t.cd-dt);
    let target=null, best=1e9;
    for(const e of state.enemies){
      if(e.dead) continue;
      const d=Math.hypot(t.x-e.x, t.y-e.y);
      if(d<=t.range && d<best){ best=d; target=e; }
    }
    if(target && t.cd<=0){
      fire(t,target);
      t.cd=1/t.rof;
    }
  }

  function fire(t,e){
    const baseSp = (t.kind==='ANTIBODY')? 180 : (t.kind==='INFLAM'?240:230);
    const ang=Math.atan2(e.y-t.y, e.x-t.x);
    const p={x:t.x,y:t.y, vx:Math.cos(ang)*baseSp, vy:Math.sin(ang)*baseSp,
             dmg:t.dmg, kind:t.kind, life:3.0, bonus:t.bonusVsMarked||0,
             mark:!!t.mark, slow:t.slow||0, splash:t.splash||0, synergy:t.synergy||0};
    if(t.kind==='ANTIBODY'){ p.homing=true; p.target=e; p.turn=6.0; }
    state.projs.push(p);
  }

  function stepProj(p,dt){
    if(p.homing){
      if(!p.target || p.target.dead){
        let nearest=null, best=1e9;
        for(const e of state.enemies){
          if(e.dead) continue;
          const d=Math.hypot(p.x-e.x, p.y-e.y);
          if(d<best){ best=d; nearest=e; }
        }
        p.target=nearest;
      }
      if(p.target){
        const desiredAng=Math.atan2(p.target.y-p.y, p.target.x-p.x);
        const curAng=Math.atan2(p.vy, p.vx);
        let diff = desiredAng - curAng;
        while(diff>Math.PI) diff-=2*Math.PI;
        while(diff<-Math.PI) diff+=2*Math.PI;
        const maxTurn=(p.turn||6)*dt;
        const newAng = curAng + Math.max(-maxTurn, Math.min(maxTurn, diff));
        const speed = Math.hypot(p.vx,p.vy);
        p.vx=Math.cos(newAng)*speed; p.vy=Math.sin(newAng)*speed;
      }
    }
    p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt;

    for(const e of state.enemies){
      if(e.dead) continue;
      const hitR = (p.kind==='ANTIBODY' || p.kind==='MACRO')? (e.r+6) : (e.r+4);
      if(Math.hypot(p.x-e.x, p.y-e.y) < hitR){
        applyHit(e, p);
        if(p.kind==='INFLAM' && p.splash){
          for(const e2 of state.enemies){
            if(e2===e || e2.dead) continue;
            if(Math.hypot(p.x-e2.x, p.y-e2.y) <= p.splash){ applyHit(e2, p, true); }
          }
        }
        state.crumb.push({x:e.x,y:e.y,life:0.18});
        p.life=0;
      }
    }
  }

  function applyHit(target, p, splash=false){
    let dmg=p.dmg;
    if(target.boss && target.shielded) dmg *= 0.5;
    if(p.kind==='MACRO' && target.marked) dmg *= (1 + (p.bonus||0.3));
    if(p.kind==='ANTIBODY' && target.marked) dmg *= (1 + (p.bonus||0.6));
    if(p.kind==='COMPLEMENT') target.marked=true;
    if(p.slow && !target.ignoreSlow) target.slow=Math.max(target.slow, splash? p.slow*0.8 : p.slow);
    target.hp -= dmg;
    if(target.hp<=0){
      target.dead=true;
      const waveMul = 1 + (state.wave-1)*0.5;
      const base = (target.boss ? BOSS_DEF[state.wave].reward : (target.reward||10));
      addCP(Math.round(base * waveMul));
      if(target.boss && state.wave===12){ spawnMinions(6); }
    }
  }

  function spawnMinions(n){
    for(let i=0;i<n;i++){
      const t = (Math.random()<0.5)?'virus':'bacteria';
      state.enemies.push(makeEnemy(t, state.basePath[0]));
    }
  }

  function makeEnemy(t, start){
    const base=ENEMY[t];
    return {type:t, x:start.x, y:start.y, wp:1, hp:base.hp, maxhp:base.hp, spd:base.spd, r:base.r, color:base.color, reward:base.reward, marked:false, slow:0, dead:false, subpath:null, subWp:0};
  }
  function spawnEnemy(t, isBoss){
    if(isBoss){
      const def=BOSS_DEF[state.wave];
      const e={boss:true, name:def.name, x:state.basePath[0].x, y:state.basePath[0].y, wp:1, hp:def.hp, maxhp:def.hp, spd:def.spd, r:def.r, color:def.color,
               reward:def.reward, marked:false, slow:0, dead:false, subpath:null, subWp:0, onTick:def.onTick, ignoreSlow:false, shielded:false, shape:def.shape};
      state.enemies.push(e);
    }else{
      state.enemies.push(makeEnemy(t, state.basePath[0]));
    }
  }

  // Render
  function drawSmoothPath(points){
    const penult=points[points.length-2], lastp=points[points.length-1];
    ctx.strokeStyle='#134f7a'; ctx.lineWidth=26; ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
    for(let i=1;i<points.length-2;i++){
      const xc=(points[i].x + points[i+1].x)/2, yc=(points[i].y + points[i+1].y)/2;
      ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
    }
    ctx.quadraticCurveTo(penult.x, penult.y, lastp.x, lastp.y); ctx.stroke();
    ctx.strokeStyle='rgba(123,227,176,0.35)'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
    for(let i=1;i<points.length-2;i++){
      const xc=(points[i].x + points[i+1].x)/2, yc=(points[i].y + points[i+1].y)/2;
      ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
    }
    ctx.quadraticCurveTo(penult.x, penult.y, lastp.x, lastp.y); ctx.stroke();
  }

  function draw(){
    ctx.fillStyle='#081224'; ctx.fillRect(0,0,W,H);
    drawSmoothPath(state.basePath);

    const now=performance.now()/1000;
    for(const n of state.nodes){
      const loop=n.gate.loop.points;
      ctx.strokeStyle='rgba(255,209,102,0.25)'; ctx.lineWidth=8;
      ctx.beginPath(); ctx.moveTo(loop[0].x, loop[0].y);
      for(let i=1;i<loop.length;i++){
        const prev=loop[i-1], cur=loop[i];
        const midx=(prev.x+cur.x)/2, midy=(prev.y+cur.y)/2;
        ctx.quadraticCurveTo(prev.x, prev.y, midx, midy);
      } ctx.stroke();

      ctx.fillStyle='#0d2c54'; ctx.beginPath(); ctx.arc(n.x,n.y,n.r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#2a5d9a'; ctx.lineWidth=2; ctx.stroke();

      if(n.tower){
        const t=n.tower;
        ctx.fillStyle=t.color; ctx.beginPath(); ctx.arc(n.x,n.y,12,0,Math.PI*2); ctx.fill();
        if(selected===t){
          ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(t.x,t.y,t.range,0,Math.PI*2); ctx.stroke();
          ctx.fillStyle='#cfe5ff'; ctx.font='12px sans-serif';
          const names={COMPLEMENT:'補體', MACRO:'巨噬細胞', INFLAM:'發炎介質', ANTIBODY:'抗體'};
          ctx.fillText(names[t.kind]+' Lv.'+t.lvl, t.x-26, t.y-18);
        }
      }
    }

    for(const e of state.enemies){
      if(e.dead) continue;
      const ratio=e.hp/e.maxhp;
      if(e.boss){
        ctx.save(); ctx.translate(e.x, e.y);
        ctx.fillStyle=e.color; ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=2;
        if(e.shape==='hex'){
          ctx.beginPath();
          for(let i=0;i<6;i++){ const a=i*Math.PI/3; const r=e.r+6; const x=Math.cos(a)*r, y=Math.sin(a)*r; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
          ctx.closePath(); ctx.fill(); ctx.stroke();
        }else if(e.shape==='star'){
          ctx.beginPath(); const R=e.r+8, r=e.r-2;
          for(let i=0;i<10;i++){ const a=i*Math.PI/5; const rr=(i%2)?r:R; const x=Math.cos(a)*rr, y=Math.sin(a)*rr; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
          ctx.closePath(); ctx.fill(); ctx.stroke();
        }else if(e.shape==='worm'){
          for(let i=0;i<5;i++){ ctx.beginPath(); ctx.arc(-i*8, (i%2?3:-3), e.r-6, 0, Math.PI*2); ctx.fill(); }
        }else{ ctx.beginPath(); ctx.arc(0,0,e.r+6,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
        if(e.shielded){ ctx.strokeStyle='rgba(255,255,255,0.7)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,e.r+12,0,Math.PI*2); ctx.stroke(); }
        ctx.restore();
      }else{
        ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();
      }
      ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(e.x,e.y,(e.boss? e.r+10: e.r+3),-Math.PI/2,-Math.PI/2+Math.PI*2*ratio); ctx.stroke();
      if(e.marked){ ctx.strokeStyle='rgba(255,230,140,.9)'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(e.x,e.y,(e.boss? e.r+14: e.r+6),0,Math.PI*2); ctx.stroke(); }
    }

    for(const p of state.projs){
      const isAB = (p.kind==='ANTIBODY');
      ctx.fillStyle = isAB ? '#ffe08a' : (p.kind==='INFLAM' ? '#ffa8a8' : (p.kind==='COMPLEMENT' ? '#9ad8ff' : '#7be3b0'));
      ctx.beginPath(); ctx.arc(p.x,p.y, isAB?5:4,0,Math.PI*2); ctx.fill();
      if(p.kind==='INFLAM' && p.splash){ ctx.globalAlpha=0.15; ctx.beginPath(); ctx.arc(p.x,p.y,p.splash,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
    }

    for(const c of state.crumb){
      ctx.globalAlpha=Math.max(0,c.life/0.18);
      ctx.fillStyle='#fff'; ctx.fillRect(c.x-1,c.y-1,2,2);
      ctx.globalAlpha=1;
    }
  }

  let last=performance.now();
  function loop(ts){
    const dt=Math.min(0.05,(ts-last)/1000); last=ts;
    if(!paused){
      state.time+=dt;
      while(state.queue.length && state.queue[0].at<=state.time){
        const s=state.queue.shift();
        if(s.boss) spawnEnemy(null,true); else spawnEnemy(s.t,false);
      }
      for(const e of state.enemies) stepEnemy(e,dt);
      state.enemies=state.enemies.filter(e=>!e.dead || e.wp<state.basePath.length);

      for(const t of state.towers) stepTower(t,dt);
      for(const p of state.projs) stepProj(p,dt);
      state.projs=state.projs.filter(p=>p.life>0);

      if(started && state.enemies.length===0 && state.queue.length===0){
        if(state.wave<state.wmax){ if(nextReady){ startWave(); } }
        else if(state.lives>0){ draw(); drawBanner('勝利！免疫系統全面壓制'); return; }
      }
    }
    draw();
    requestAnimationFrame(loop);
  }

  function drawBanner(text){
    ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#fff'; ctx.font='28px sans-serif';
    const tw=ctx.measureText(text).width; ctx.fillText(text, (W-tw)/2, H/2);
  }

  function startWave(){
    if(state.wave>=state.wmax) return;
    if(state.wave>=1){
      state.basePath = makeRandomWinding();
      rebuildNodesAndLoops();
    }
    state.wave++; ui.wave.textContent=state.wave;
    unlockByWave(state.wave);
    if(state.wave===4 || state.wave===8 || state.wave===12){
      addNewNodeIndices(2);
      rebuildNodesAndLoops();
      flashToast('新增 2 個站點！');
    }
    state.queue.length=0;
    const pack=waves[state.wave-1];
    for(const s of pack) state.queue.push({t:s.t, boss:!!s.boss, at:state.time+s.at});
    nextReady=false;
  }

  // Kick off & controls
  draw();
  requestAnimationFrame(loop);
  window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); paused=!paused; btn.pause.textContent=paused?'繼續':'暫停'; }}, {passive:false});
  window.addEventListener('blur', ()=>{ paused=true; btn.pause.textContent='繼續'; });
})();
</script>
</body>
</html>
