<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>體循環／肺循環 3D 紅血球模擬（線上版）</title>
<style>
  html,body{margin:0;height:100%;background:#0b0f14;color:#e8e8e8;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans TC","PingFang TC","Helvetica Neue",Arial,"Microsoft JhengHei",sans-serif;overflow:hidden;touch-action:none}
  #app{position:fixed;inset:0}
  canvas.chart{position:fixed;right:10px;top:10px;width:min(260px,38vw);height:min(180px,28vh);z-index:5;border:1px solid rgba(255,255,255,.12);background:rgba(12,16,22,.82);border-radius:10px}
  .hud{position:fixed;left:10px;top:10px;display:grid;gap:8px;z-index:10;max-width:min(92vw,420px)}
  .panel{background:rgba(12,16,22,.82);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px 12px;backdrop-filter:blur(6px);box-shadow:0 6px 20px rgba(0,0,0,.35)}
  .modes{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .btn{appearance:none;border:1px solid rgba(255,255,255,.12);background:linear-gradient(180deg,rgba(30,35,45,.9),rgba(18,22,28,.9));color:#eaeaea;padding:9px 10px;border-radius:10px;cursor:pointer;font-size:14px;line-height:1;transition:transform .06s ease,border-color .2s ease,background .2s ease;white-space:nowrap}
  .btn:hover{transform:translateY(-1px);border-color:rgba(255,96,96,.6)}
  .btn.active{background:linear-gradient(180deg,rgba(140,18,28,.95),rgba(90,10,16,.95));border-color:rgba(255,96,96,.9)}
  .legend{display:grid;gap:6px;font-size:12px}
  .kpi{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .kpi b{font-size:16px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .seg{display:inline-flex;gap:0}
  .seg .btn{border-radius:10px 0 0 10px}
  .seg .btn + .btn{border-left:none;border-radius:0}
  .seg .btn:last-child{border-radius:0 10px 10px 0}
  .slider{width:min(220px,50vw)}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.15);background:rgba(255,255,255,.06);font-size:12px}
  .footer{position:fixed;right:10px;bottom:10px;font-size:12px;opacity:.85;background:rgba(12,16,22,.65);padding:6px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.08);backdrop-filter:blur(6px);z-index:10}
</style>
</head>
<body>
<div id="app"></div>
<canvas id="chart" class="chart" width="520" height="360"></canvas>

<div class="hud">
  <div class="panel">
    <div style="font-weight:600;margin-bottom:6px;">血流模式</div>
    <div class="modes">
      <button class="btn" id="mode-sleep">睡眠</button>
      <button class="btn active" id="mode-rest">平時</button>
      <button class="btn" id="mode-ex">運動</button>
    </div>
  </div>

  <div class="panel legend">
    <div class="kpi">HR：<b id="hr">70</b> bpm　速度：<b id="speed">1.0×</b>　粒子：<b id="count">1,800</b></div>
    <div class="row">
      外殼透明度 <input id="alpha" class="slider" type="range" min="0" max="100" value="40"><span id="alphaVal">0.40</span>
    </div>
    <div class="row">
      統計圖
      <div class="seg" style="margin-left:6px">
        <button class="btn active" id="chart-pie">圓餅</button>
        <button class="btn" id="chart-line">折線</button>
      </div>
    </div>
    <div class="row" style="font-size:12px">
      位置：<span class="badge">心臟（中心，四腔室）</span>｜<span class="badge">肺（右）</span>｜<span class="badge">全身（左）</span>
    </div>
  </div>
</div>

<div class="footer">拖曳旋轉｜滾輪/雙指縮放｜右鍵平移</div>

<!-- Three.js r160 CDN（全球快取）-->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
(() => {
  const app = document.getElementById('app');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0f14);

  // Renderer (DPR調節，避免行動裝置過載)
  const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  renderer.setPixelRatio(DPR);
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  app.appendChild(renderer.domElement);

  // Camera & responsive initial distance
  const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 2000);
  const baseDist = Math.max(56, Math.min(74, Math.hypot(innerWidth, innerHeight)/16));
  camera.position.set(0, 22, baseDist);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;
  controls.minDistance = 18;
  controls.maxDistance = 160;
  controls.enablePan = true;

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x101018, 0.9);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(40, 60, 20);
  dir.castShadow = true;
  scene.add(dir);

  // Ground
  const ground = new THREE.Mesh(new THREE.CircleGeometry(160, 64), new THREE.MeshStandardMaterial({ color: 0x0e131a, metalness: 0.1, roughness: 0.9 }));
  ground.receiveShadow = true;
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -18;
  scene.add(ground);

  // Key positions
  const HEART = new THREE.Vector3(0,0,0);
  const LUNG  = new THREE.Vector3(38,6,0);
  const BODY  = new THREE.Vector3(-38,-4,0);

  // Four-chamber translucent shells
  const shellMat = new THREE.MeshPhysicalMaterial({
    color: 0xffec80, metalness: 0.0, roughness: 0.6,
    transmission: 0.75, transparent: true, opacity: 0.4, thickness: 0.25, ior: 1.1
  });
  const shells = [];
  function addChamber(center, scale, rotY=0){
    const g = new THREE.SphereGeometry(1, 14, 12);
    const m = new THREE.Mesh(g, shellMat);
    m.castShadow = m.receiveShadow = true;
    m.position.copy(center);
    m.scale.set(scale.x, scale.y, scale.z);
    m.rotation.y = rotY;
    scene.add(m);
    shells.push(m);
    return m;
  }
  addChamber(new THREE.Vector3(-3, 2,  2), new THREE.Vector3(3.6, 3.8, 3.0),  0.10); // RA
  addChamber(new THREE.Vector3(-1,-2,  1), new THREE.Vector3(4.2, 4.6, 3.2), -0.10); // RV
  addChamber(new THREE.Vector3( 3, 2, -2), new THREE.VectorVector3? (3.4, 3.6, 2.9): new THREE.Vector3(3.4,3.6,2.9), -0.08); // LA (fallback for template quirk)
  addChamber(new THREE.Vector3( 3,-2,  0), new THREE.Vector3(4.6, 5.0, 3.4),  0.12); // LV

  // Major vessels (semi-transparent yellow tubes)
  const vesselMat = new THREE.MeshPhysicalMaterial({ color: 0xffec80, transparent: true, opacity: 0.22, metalness: 0, roughness: 0.7, transmission: 0.5 });
  function addTube(points, r){
    const curve = new THREE.CatmullRomCurve3(points, false, 'centripetal', 0.6);
    const geo = new THREE.TubeGeometry(curve, 64, r, 16, false);
    const mesh = new THREE.Mesh(geo, vesselMat);
    mesh.castShadow = mesh.receiveShadow = true;
    scene.add(mesh);
    return mesh;
  }
  addTube([ new THREE.Vector3( 3,-2, 0), new THREE.Vector3(-6, 1, 1), new THREE.Vector3(-14, 8, 2) ], 1.1); // Aorta
  addTube([ new THREE.Vector3(-1,-2, 1), new THREE.Vector3( 8, 0,-1), new THREE.Vector3( 20, 2,-2) ], 1.0); // Pulmonary Artery
  addTube([ new THREE.Vector3(30, 6,-1), new THREE.Vector3(18, 6, 0), new THREE.Vector3( 6, 4, 1) ], 0.9);  // Pulmonary Vein
  addTube([ new THREE.Vector3(-24, 6, 2), new THREE.Vector3(-12,4, 2), new THREE.Vector3(-3, 2, 2) ], 1.0); // Vena Cava

  // Heart beat core
  const heartPulse = new THREE.Mesh(new THREE.SphereGeometry(3.2, 18, 18), new THREE.MeshStandardMaterial({ color: 0xa2121f, emissive: 0x2a0000, metalness: 0.15, roughness: 0.45 }));
  heartPulse.position.copy(HEART);
  scene.add(heartPulse);

  // Main loop curve (closed)
  function mkLoop(points){ return new THREE.CatmullRomCurve3(points, true, 'centripetal', 0.65); }
  const W = [
    new THREE.Vector3(-3, 2, 2),   // RA
    new THREE.Vector3(-1,-2, 1),   // RV
    new THREE.Vector3( 8, 1,-1), new THREE.Vector3(20, 2,-2), // PulmArt
    LUNG.clone(),                   // LungCap (oxygenate)
    new THREE.Vector3(18, 6, 0), new THREE.Vector3(6, 4, 1),   // PulmVein
    new THREE.VectorVector3?(3, 2,-2):new THREE.Vector3(3,2,-2),     // LA
    new THREE.Vector3(3,-2, 0),     // LV
    new THREE.Vector3(-6, 1, 1), new THREE.Vector3(-14, 8, 2), // Aorta
    new THREE.Vector3(-22, 6, 2), BODY.clone(),                // SysCap (deoxygenate)
    new THREE.Vector3(-6, 0, 1), new THREE.Vector3(-3, 2, 2),  // Vena Cava → RA
  ];
  const curve = mkLoop(W);
  const pathVis = new THREE.Mesh(
    new THREE.TubeGeometry(curve, 540, 1.4, 18, true),
    new THREE.MeshStandardMaterial({ color: 0x6a0d15, metalness: 0.1, roughness: 0.45, transparent: true, opacity: 0.55 })
  );
  pathVis.castShadow = pathVis.receiveShadow = true;
  scene.add(pathVis);

  // RBC particles (InstancedMesh with per-instance color)
  const MAX = 2600;
  const rGeo = new THREE.SphereGeometry(0.36, 10, 10);
  const rMat = new THREE.MeshStandardMaterial({ vertexColors: true, emissive: 0x0, roughness: 0.35, metalness: 0.0 });
  const rbc = new THREE.InstancedMesh(rGeo, rMat, MAX);
  rbc.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  rbc.frustumCulled = false;
  rbc.castShadow = true;
  scene.add(rbc);

  const red = new THREE.Color('#e03a3a');
  const blue = new THREE.Color('#2e6ae6');

  const tmpMat = new THREE.Matrix4();
  const tmpPos = new THREE.Vector3();
  const tmpAhead = new THREE.Vector3();
  const tmpOpp = new THREE.Vector3();
  const nrm = new THREE.Vector3();
  const side = new THREE.Vector3();
  const up = new THREE.Vector3();

  const particles = [];
  let activeCount = 1800;

  function rand(){ return Math.random(); }
  function place(i, t, radial, az){
    curve.getPointAt(t%1, tmpPos);
    curve.getPointAt((t+0.002)%1, tmpAhead);
    curve.getPointAt((t+0.5)%1, tmpOpp);
    nrm.subVectors(tmpAhead, tmpPos).normalize();
    side.crossVectors(nrm, tmpOpp.sub(tmpPos).normalize()).normalize();
    up.crossVectors(nrm, side).normalize();
    tmpPos.addScaledVector(side, Math.sin(az)*radial);
    tmpPos.addScaledVector(up, Math.cos(az)*radial*0.5);
    tmpMat.setPosition(tmpPos);
    rbc.setMatrixAt(i, tmpMat);
  }
  function setColor(i, c){ rbc.setColorAt(i, c); }

  function initParticles(){
    for (let i=0;i<MAX;i++){
      const t = rand();
      const base = 0.06*(0.7+rand()*0.6);
      const radial = (rand()*2-1)*0.35;
      const az = rand()*Math.PI*2;
      const pulse = rand();
      const oxy = false;
      particles.push({t, base, radial, az, pulse, oxy});
      place(i, t, radial, az);
      setColor(i, blue);
      if (i>=activeCount){ tmpMat.setPosition(0,-9999,0); rbc.setMatrixAt(i, tmpMat); }
    }
    rbc.instanceMatrix.needsUpdate = true;
    rbc.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(MAX*3), 3);
    rbc.instanceColor.needsUpdate = true;
  }
  initParticles();

  // Mode & HUD
  const MODE={SLEEP:{hr:52,speedMul:0.6,count:1200},REST:{hr:70,speedMul:1.0,count:1800},EX:{hr:140,speedMul:1.9,count:2600}};
  let target={...MODE.REST};
  let display={hr:MODE.REST.hr, speedMul:1.0, count:activeCount};

  const $hr=document.getElementById('hr');
  const $spd=document.getElementById('speed');
  const $cnt=document.getElementById('count');
  function updateHUD(){ $hr.textContent=Math.round(display.hr); $spd.textContent=display.speedMul.toFixed(1)+'×'; $cnt.textContent=Math.round(display.count).toLocaleString(); }
  function setMode(m){ target={...m}; document.querySelectorAll('.modes .btn').forEach(b=>b.classList.remove('active')); if(m===MODE.SLEEP)document.getElementById('mode-sleep').classList.add('active'); if(m===MODE.REST)document.getElementById('mode-rest').classList.add('active'); if(m===MODE.EX)document.getElementById('mode-ex').classList.add('active'); }
  document.getElementById('mode-sleep').onclick=()=>setMode(MODE.SLEEP);
  document.getElementById('mode-rest').onclick=()=>setMode(MODE.REST);
  document.getElementById('mode-ex').onclick=()=>setMode(MODE.EX);

  // Opacity slider
  const alpha = document.getElementById('alpha'), alphaVal=document.getElementById('alphaVal');
  alpha.addEventListener('input', ()=>{
    const a = (+alpha.value)/100;
    shellMat.opacity = a;
    vesselMat.opacity = Math.max(0.12, a*0.6);
    alphaVal.textContent = a.toFixed(2);
  });

  // Chart (pie / line)
  const chart = document.getElementById('chart');
  const g = chart.getContext('2d');
  let chartMode='pie'; const historyLen=300; const oxyHistory=new Array(historyLen).fill(0.5);
  document.getElementById('chart-pie').onclick=()=>{chartMode='pie'; document.getElementById('chart-pie').classList.add('active'); document.getElementById('chart-line').classList.remove('active'); };
  document.getElementById('chart-line').onclick=()=>{chartMode='line'; document.getElementById('chart-line').classList.add('active'); document.getElementById('chart-pie').classList.remove('active'); };

  function drawChart(ratio){
    g.clearRect(0,0,chart.width,chart.height);
    g.fillStyle='rgba(12,16,22,.82)'; g.fillRect(0,0,chart.width,chart.height);
    g.strokeStyle='rgba(255,255,255,.12)'; g.strokeRect(0.5,0.5,chart.width-1,chart.height-1);
    if(chartMode==='pie'){
      const cx=chart.width*0.34, cy=chart.height*0.56, R=Math.min(chart.width,chart.height)*0.33, start=-Math.PI/2, end=start+ratio*Math.PI*2;
      g.beginPath(); g.moveTo(cx,cy); g.arc(cx,cy,R,start,start+Math.PI*2); g.closePath(); g.fillStyle='#2e6ae6'; g.fill();
      g.beginPath(); g.moveTo(cx,cy); g.arc(cx,cy,R,start,end); g.closePath(); g.fillStyle='#e03a3a'; g.fill();
      g.fillStyle='#e8e8e8'; g.font='20px sans-serif'; g.fillText('含氧', chart.width*0.72, 38); g.fillText('缺氧', chart.width*0.72, 76);
      g.fillStyle='#e03a3a'; g.fillRect(chart.width*0.72-30, 26, 20, 10);
      g.fillStyle='#2e6ae6'; g.fillRect(chart.width*0.72-30, 64, 20, 10);
      g.fillStyle='#bbb'; g.font='18px sans-serif'; g.fillText((ratio*100).toFixed(0)+'%', chart.width*0.72, 116);
    } else {
      const pad=16, gw=chart.width-pad*2, gh=chart.height-pad*2; g.save(); g.translate(pad,pad);
      g.strokeStyle='rgba(255,255,255,.12)'; g.strokeRect(0.5,0.5,gw-1,gh-1);
      g.beginPath(); for(let i=1;i<5;i++){ const gy=(gh/5)*i; g.moveTo(0,gy); g.lineTo(gw,gy); } g.strokeStyle='rgba(255,255,255,.08)'; g.stroke();
      g.beginPath(); for(let i=0;i<oxyHistory.length;i++){ const k=i/(oxyHistory.length-1); const x=k*gw, y=(1-oxyHistory[i])*gh; if(i===0) g.moveTo(x,y); else g.lineTo(x,y); } g.lineWidth=3; g.strokeStyle='#e03a3a'; g.stroke();
      g.beginPath(); for(let i=0;i<oxyHistory.length;i++){ const k=i/(oxyHistory.length-1); const x=k*gw, y=(oxyHistory[i])*gh; if(i===0) g.moveTo(x,y); else g.lineTo(x,y); } g.lineWidth=2; g.strokeStyle='#2e6ae6'; g.stroke();
      g.restore();
    }
  }

  // Oxygenation switching along the loop
  // Use curve.getUtoTmapping to map approximate arclength fractions for lung/body key points
  const uLung  = curve.getUtoTmapping(0.20);  // near lung
  const uBody  = curve.getUtoTmapping(0.72);  // near body
  function isOxygenated(t){
    // treat [uLung, uBody) as oxygenated
    if (uLung < uBody) return t>=uLung && t<uBody;
    return t>=uLung || t<uBody;
  }

  // Animate
  let last = performance.now();
  function animate(now){
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, (now - last)/1000); last = now;

    display.hr        = THREE.MathUtils.damp(display.hr, target.hr, 4, dt);
    display.speedMul  = THREE.MathUtils.damp(display.speedMul, target.speedMul, 4, dt);
    display.count     = THREE.MathUtils.damp(display.count, target.count, 6, dt);
    updateHUD();

    const pulsePhase  = (now*0.001) * (display.hr/60) * Math.PI*2;
    const pulseScale  = 1.0 + Math.max(0, Math.sin(pulsePhase)) * 0.06;
    heartPulse.scale.setScalar(pulseScale);
    shells.forEach(s => { s.scale.y = s.scale.y * (0.995 + Math.max(0, Math.sin(pulsePhase))*0.02); });

    // Particles
    let oxyCount = 0;
    const maxActive = Math.min(MAX, Math.max(200, Math.round(display.count)));
    for (let i=0;i<maxActive;i++){
      if (!particles[i]) {
        // in case of increasing count new particles needed
        const t = rand();
        const base = 0.06*(0.7+rand()*0.6);
        const radial = (rand()*2-1)*0.35;
        const az = rand()*Math.PI*2;
        const pulse = rand();
        particles[i] = {t, base, radial, az, pulse, oxy:false};
      }
      const p = particles[i];
      const cardiac = 1 + Math.max(0, Math.sin(pulsePhase + p.pulse))*0.12;
      const speed = p.base * display.speedMul * cardiac;
      p.t += speed * dt * 0.06; if (p.t > 1) p.t -= 1;
      p.oxy = isOxygenated(p.t);
      oxyCount += p.oxy ? 1 : 0;

      const jitter = Math.sin(now*0.001 + i*0.13)*0.25;
      const radial = p.radial + jitter*0.12;
      place(i, p.t, radial, p.az);
      setColor(i, p.oxy ? red : blue);
    }
    // hide the rest
    for (let i=maxActive;i<MAX;i++){ tmpMat.setPosition(0,-9999,0); rbc.setMatrixAt(i, tmpMat); }
    rbc.instanceMatrix.needsUpdate = true;
    if (rbc.instanceColor) rbc.instanceColor.needsUpdate = true;

    const ratio = oxyCount / Math.max(1, maxActive);
    // update history roughly every 0.1s
    if(Math.floor(now/100)!==Math.floor((now-dt*1000)/100)){ oxyHistory.push(ratio); if(oxyHistory.length>historyLen) oxyHistory.shift(); }
    drawChart(ratio);

    controls.update();
    renderer.render(scene, camera);
  }
  requestAnimationFrame(animate);

  // Mode buttons
  function wireMode(id, preset){ document.getElementById(id).onclick = ()=>{ setMode(preset); }; }
  wireMode('mode-sleep', MODE.SLEEP);
  wireMode('mode-rest',  MODE.REST);
  wireMode('mode-ex',    MODE.EX);

  // Resize
  addEventListener('resize', ()=>{
    renderer.setPixelRatio(Math.min(devicePixelRatio || 1, 2));
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
  }, {passive:true});
})();
</script>
</body>
</html>
