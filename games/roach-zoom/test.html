<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>é€é¡æˆåƒ Ã— æ”¾å¤§é¡ Ã— é¦¬é”åŠ æ–¯åŠ èŸ‘è‚ï½œv1 (1004) + æ–°åŠŸèƒ½</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background:#0e1116; color:#eaeef5; font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Arial, "Microsoft JhengHei", sans-serif; }
    .wrap { display:flex; flex-direction:column; min-height:100vh; }

    /* æ¥µç°¡æŠ¬é ­åˆ—ï¼šç„¦è·æ»‘æ¡¿ + èªªæ˜æŒ‰éˆ• */
    header { padding:8px 12px; background:linear-gradient(180deg,#121722,#0e1116); border-bottom:1px solid #1b2130; position:sticky; top:0; z-index:2; }
    .topbar { display:flex; align-items:center; gap:12px; }
    .spacer { flex:1; }
    label { font-size:12px; opacity:0.95; }
    input[type=range] { width:min(360px, 60vw); }
    .btn { cursor:pointer; user-select:none; padding:6px 10px; border-radius:10px; font-size:12px; border:1px solid #2a3752; background:#141b28; color:#cfe1ff; }

    /* éŠæˆ²å€æœ€å¤§åŒ– */
    #canvas { flex:1; display:block; width:100%; height:auto; background: radial-gradient(1200px 180px at 50% 0%, #0b0f16, #0c1018); touch-action: none; }

    /* é€šé—œé¢æ¿ */
    #win { position:fixed; inset:0; background:rgba(0,0,0,0.6); display:none; align-items:center; justify-content:center; z-index:5; }
    #win .panel { width:min(920px, 92vw); max-height:90vh; overflow:auto; background:#121826; border:1px solid #2b3a57; border-radius:16px; box-shadow:0 12px 40px rgba(0,0,0,0.4); padding:16px; }
    #win h2 { margin:0 0 8px; font-size:18px; }
    #win table { width:100%; border-collapse: collapse; font-size:12px; }
    #win th, #win td { border-bottom:1px solid #2b3a57; padding:6px 8px; text-align:left; }
    #win .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }
    .btn-outline { background:#141b28; border:1px solid #2a3752; color:#cfe1ff; padding:6px 10px; border-radius:10px; }
    .btn-primary { background:#2a6fff; border:0; color:white; padding:6px 12px; border-radius:10px; }

    /* èªªæ˜é¢æ¿ï¼ˆé è¨­éš±è—ï¼‰ */
    #help { position:fixed; inset:0; background:rgba(0,0,0,0.55); display:none; align-items:center; justify-content:center; z-index:6; }
    #help .panel { width:min(700px, 92vw); max-height:88vh; overflow:auto; background:#121826; border:1px solid #2b3a57; border-radius:16px; box-shadow:0 12px 40px rgba(0,0,0,0.4); padding:16px; }
    #help h2 { margin:0 0 8px; font-size:18px; }
    #help .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }
    #helpContent { white-space:pre-wrap; line-height:1.6; font-size:13px; color:#d7e4ff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Arial, "Microsoft JhengHei", sans-serif; }
    #helpContent code, #helpContent pre { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    #helpContent pre { background:#0d1422; padding:10px; border-radius:10px; border:1px solid #25324a; overflow:auto; }

    /* æ¸¬è©¦å¾½ç«  */
    #testBadge { position:fixed; right:8px; bottom:8px; background:#142034; color:#cde3ff; border:1px solid #2a3e63; border-radius:10px; padding:6px 10px; font-size:12px; display:none; z-index:10; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="topbar">
      <label>ç„¦è· fï¼ˆcmï¼‰ï¼š<input id="fSlider" type="range" min="10" max="100" step="1" value="50"> <span id="fVal">50</span> cm</label>
      <div class="spacer"></div>
      <button id="btnHelp" class="btn">èªªæ˜</button>
    </div>
  </header>

  <canvas id="canvas"></canvas>
</div>

<!-- Win overlay -->
<div id="win">
  <div class="panel">
    <h2>ğŸ‰ é€šé—œæˆåŠŸï¼ä¸‰ç¨®ç„¦æ®µå·²å®Œæˆé…å°ä¸¦ç”Ÿå‡º 18 éš»å°èŸ‘è‚</h2>
    <div id="winSummary"></div>
    <div class="actions">
      <button id="btnCloseWin" class="btn-outline">é—œé–‰</button>
      <button id="btnRestart" class="btn-primary">å†ç©ä¸€æ¬¡</button>
    </div>
  </div>
</div>

<!-- Help overlay (rules) -->
<div id="help">
  <div class="panel">
    <h2>ğŸ“˜ éŠæˆ²èªªæ˜</h2>
    <div id="helpContent">ï¼ˆæ­£åœ¨è¼‰å…¥ readme.mdâ€¦ï¼‰</div>
    <div class="actions">
      <button id="btnCloseHelp" class="btn-outline">é—œé–‰</button>
    </div>
  </div>
</div>

<div id="testBadge">âœ… Tests passed</div>

<script>
// version tag: v1 (1004 baseline) + 1005 additions
(function(){
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // ---------- Sizing ----------
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssW = canvas.clientWidth || window.innerWidth;
    const headerH = document.querySelector('header') ? document.querySelector('header').offsetHeight : 0;
    const cssH = canvas.clientHeight || (window.innerHeight - headerH);
    canvas.width  = Math.max(1, Math.floor(cssW * dpr));
    canvas.height = Math.max(1, Math.floor(cssH * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  window.addEventListener('load', resize);
  requestAnimationFrame(resize);

  // ---------- World / State ----------
  const H = 3.0; // meters (top 0 â†’ bottom H)
  const marginTop = 20;
  const getDPR = () => Math.max(1, window.devicePixelRatio || 1);
  const pxPerM = () => (canvas.height/getDPR() - 40) / H;

  const roach = { x:1.5, y:0, dir:1, speed:0.35, phase:0 };
  let lens = { x:2.0, y:1.5, f:0.50 };

  const clones = []; // clone schema
  const hearts = [];
  const souls = []; // {x, y, t}

  // families: key=f_cm â†’ { f_cm, parents:[parentA,parentB], babies }
  const families = new Map();

  // Bulb state
  const bulb = { x: () => (canvas.width/getDPR())/2/pxPerM(), y: 0, on: true };

  // ---------- UI ----------
  const fSlider = document.getElementById('fSlider');
  const fVal = document.getElementById('fVal');
  const btnHelp = document.getElementById('btnHelp');
  const helpEl = document.getElementById('help');
  const btnCloseHelp = document.getElementById('btnCloseHelp');
  const helpContent = document.getElementById('helpContent');
  const winEl = document.getElementById('win');
  const winSummary = document.getElementById('winSummary');
  const btnCloseWin = document.getElementById('btnCloseWin');
  const btnRestart = document.getElementById('btnRestart');

  fSlider.addEventListener('input', () => {
    lens.f = parseFloat(fSlider.value)/100;
    fVal.textContent = fSlider.value;
  });
  btnHelp.addEventListener('click', async ()=> { await loadReadme(); helpEl.style.display='flex'; });
  btnCloseHelp.addEventListener('click', ()=> helpEl.style.display='none');
  btnCloseWin.addEventListener('click', ()=> winEl.style.display='none');
  btnRestart.addEventListener('click', ()=> location.reload());

  // ---------- Pointer handling ----------
  let touching = false;
  function updateLensFromPointer(e){
    const rect = canvas.getBoundingClientRect();
    lens.x = (e.clientX - rect.left) / pxPerM();
    lens.y = (e.clientY - rect.top - marginTop) / pxPerM();
    lens.y = Math.max(0.1, Math.min(H-0.1, lens.y));
    const maxX = (canvas.clientWidth-0.3*pxPerM())/pxPerM();
    lens.x = Math.max(0.3, Math.min(maxX, lens.x));
  }

  canvas.addEventListener('pointerdown', (e)=>{
    if (e.pointerType === 'touch'){
      touching = true; updateLensFromPointer(e); e.preventDefault();
    }
  }, {passive:false});
  canvas.addEventListener('pointermove', (e)=>{
    if (e.pointerType === 'touch'){
      if (!touching) return; updateLensFromPointer(e); e.preventDefault();
    } else { updateLensFromPointer(e); }
  }, {passive:false});
  canvas.addEventListener('pointerup', (e)=>{
    if (e.pointerType === 'touch'){
      touching = false; attemptClone(); e.preventDefault();
    }
  }, {passive:false});
  canvas.addEventListener('pointercancel', ()=>{ touching=false; });
  canvas.addEventListener('click', (e)=>{ if (e.pointerType !== 'touch') attemptClone(); });

  // ---------- Physics ----------
  function computeImaging(){
    const s_geom = Math.max(0.001, lens.y - roach.y); // downward +
    const f = lens.f;
    const sp_geom = 1/(1/f - 1/s_geom); // >0 real, <0 virtual
    const m = -sp_geom/s_geom;
    const y_img = lens.y + sp_geom;
    const x_img = lens.x + m * (roach.x - lens.x);
    const s_signed = s_geom;      // s æ­£
    const sp_signed = -sp_geom;   // å¯¦åƒåœ¨ä¸‹æ–¹â†’è² 
    const type = (sp_geom>0? 'å¯¦åƒï¼ˆå€’ç«‹ï¼‰' : 'è™›åƒï¼ˆæ­£ç«‹ï¼‰');
    const err = sp_geom>0 ? Math.abs(y_img - H) : Math.abs(y_img - 0);
    return { s_signed, sp_signed, m, y_img, x_img, err, sp_geom, type };
  }

  function shadeByF(fcm, sex){
    const t = Math.max(0, Math.min(1, (fcm-10)/90));
    if (sex==='F'){ const S = 70 - t*15; const L = 78 - t*16; return `hsl(340 ${S}% ${L}%)`; }
    else { const S = 60 - t*15; const L = 76 - t*16; return `hsl(110 ${S}% ${L}%)`; }
  }

  function attemptClone(){
    const calc = computeImaging();
    const tol = 0.02; // 2 cm
    let onTarget = false;
    if (calc.sp_geom > 0 && Math.abs(calc.y_img - H) < tol) onTarget = true;
    if (calc.sp_geom < 0 && Math.abs(calc.y_img - 0) < tol) onTarget = true;
    if (!onTarget) return;

    const mAbs = Math.abs(calc.m);
    const f_cm = Math.round(lens.f * 100);
    const focusBin = f_cm;
    const sex = (mAbs>=1.0) ? 'F' : 'M';
    const color = shadeByF(f_cm, sex);
    const alpha = 0.55;
    const dir = Math.random()<0.5?-1:1;
    const speed = 0.18 + Math.random()*0.22;
    const isReal = (calc.sp_geom>0);

    clones.push({
      x: calc.x_img,
      y: isReal ? H : 0,
      scale: Math.max(0.2, Math.min(2.2, Math.abs(calc.m))),
      dir, speed,
      phase: Math.random()*Math.PI*2,
      sex, color, alpha,
      f_cm, focusBin,
      status:'free', targetX:null, hasBirthed:false,
      isBaby:false,
      inverted: isReal, // å¯¦åƒå€’ç«‹ã€è™›åƒæ­£ç«‹
      s_signed: calc.s_signed,
      sp_signed: calc.sp_signed,
      type: calc.type,
      m: calc.m,
      dead:false, deathT:0, corpseAlpha:1, corpseFading:false, hidden:false
    });
  }

  // ---------- Drawing ----------
  function drawWorldGrid(){
    const p = pxPerM();
    ctx.fillStyle = '#0b1018';
    ctx.fillRect(0, marginTop, canvas.width/getDPR(), H*p);
    ctx.strokeStyle = '#243149';
    ctx.beginPath(); ctx.moveTo(0, marginTop); ctx.lineTo(canvas.width/getDPR(), marginTop); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, marginTop + H*p); ctx.lineTo(canvas.width/getDPR(), marginTop + H*p); ctx.stroke();
    ctx.fillStyle = '#8ea4c8'; ctx.font = '12px system-ui';
    ctx.fillText('å¤©èŠ±æ¿', 8, marginTop+12);
    ctx.fillText('åœ°æ¿', 8, marginTop + H*p - 6);
  }

  function drawRuler(calc){
    const p = pxPerM();
    const baseX = canvas.width/getDPR() - 80;
    const zeroY = marginTop + lens.y * p;
    ctx.save();
    ctx.strokeStyle = '#2c3b57'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(baseX, marginTop); ctx.lineTo(baseX, marginTop + H*p); ctx.stroke();
    ctx.strokeStyle = '#7fb8ff'; ctx.beginPath(); ctx.moveTo(baseX-8, zeroY); ctx.lineTo(baseX+8, zeroY); ctx.stroke();
    ctx.fillStyle = '#9fc8ff'; ctx.font = '12px system-ui'; ctx.fillText('0', baseX+12, zeroY-4);
    const sY = zeroY - calc.s_signed * p;
    ctx.strokeStyle = '#7bdcff'; ctx.beginPath(); ctx.moveTo(baseX-5, sY); ctx.lineTo(baseX+5, sY); ctx.stroke();
    ctx.fillStyle = '#7bdcff'; ctx.fillText(`s=${calc.s_signed.toFixed(2)}m`, baseX+12, sY-4);
    const spY = zeroY + (-calc.sp_signed) * p;
    ctx.strokeStyle = '#ffd48a'; ctx.beginPath(); ctx.moveTo(baseX-5, spY); ctx.lineTo(baseX+5, spY); ctx.stroke();
    ctx.fillStyle = '#ffd48a'; ctx.fillText(`s'=${calc.sp_signed.toFixed(2)}m`, baseX+12, spY-4);
    ctx.restore();
  }

  function drawLens(){
    // é›™å‡¸é€é¡å¤–è§€ï¼šæ°´å¹³ï¼ˆèˆ‡å¤©èŠ±æ¿/åœ°æ¿å¹³è¡Œï¼‰ï¼Œåƒ…æ”¹å¤–è§€ä¸æ”¹æˆåƒå¹¾ä½•
    const p = pxPerM();
    const x = lens.x * p;
    const y = marginTop + lens.y * p;
    ctx.save();
    ctx.translate(x, y);

    // æ°´å¹³é›™å‡¸ï¼šå¯¬ wã€åš hï¼ˆæ°´å¹³æ–¹å‘è®Šé•·ï¼‰
    const w = 68, h = 22;
    const grd = ctx.createLinearGradient(-w, -h, w, h);
    grd.addColorStop(0, 'rgba(160,210,255,0.16)');
    grd.addColorStop(0.5, 'rgba(220,245,255,0.38)');
    grd.addColorStop(1, 'rgba(160,210,255,0.16)');
    ctx.fillStyle = grd;
    ctx.strokeStyle = 'rgba(120,170,230,0.95)';
    ctx.lineWidth = 1.2;

    // é›™å‡¸è¼ªå»“ï¼ˆæ°´å¹³ï¼‰
    ctx.beginPath();
    ctx.moveTo(-w, 0);
    ctx.bezierCurveTo(-w*0.55, -h*1.1, w*0.55, -h*1.1, w, 0);
    ctx.bezierCurveTo(w*0.55, h*1.1, -w*0.55, h*1.1, -w, 0);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // ä¸­å¿ƒç·šï¼ˆå‚ç›´å°ç·šæ®µï¼‰
    ctx.strokeStyle = 'rgba(180,220,255,0.85)';
    ctx.beginPath();
    ctx.moveTo(0, -26);
    ctx.lineTo(0, 26);
    ctx.stroke();

    // ç„¦è·è™›ç·šï¼ˆæ–¼é¡é¢å±€éƒ¨åº§æ¨™ y=Â±fï¼‰
    const fpx = lens.f * p;
    ctx.setLineDash([3,3]);
    ctx.strokeStyle='rgba(200,240,255,0.6)';
    ctx.beginPath();
    ctx.moveTo(-12, -fpx);
    ctx.lineTo(12, -fpx);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-12,  fpx);
    ctx.lineTo(12,  fpx);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.restore();
  }

  function drawBulbAndFocus(calc){
    const p = pxPerM();
    // å¤©èŠ±æ¿ä¸­å¤®ç‡ˆæ³¡
    const bx = (canvas.width/getDPR())/2; const by = marginTop;
    ctx.save();
    ctx.strokeStyle = '#33435f'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(bx, marginTop); ctx.lineTo(bx, marginTop+20); ctx.stroke();
    ctx.fillStyle = 'rgba(255,240,158,0.15)'; ctx.beginPath(); ctx.arc(bx, by+28, 34, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffe98a'; ctx.strokeStyle = '#423b17'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.ellipse(bx, by+28, 14, 20, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.restore();

    // èšç„¦æ¢ä»¶ï¼šé¡åˆ°åœ°æ¿è·é›¢ = fï¼ˆå®¹å·® 1 cmï¼‰
    const diff = Math.abs((H - lens.y) - lens.f);
    const focusOnFloor = diff < 0.01;
    if (!focusOnFloor) return {focusOnFloor:false};

    // åƒ…å…©æ¢æ›´ç´°çš„åŒ¯èšå…‰ç·š
    const focusX = lens.x * p; const floorY = marginTop + H*p; const yLensPx = marginTop + lens.y*p;
    ctx.save();
    const offsets = [-80, 80];
    ctx.strokeStyle = 'rgba(255,240,120,0.9)';
    ctx.lineWidth = 1.0; // æ›´ç´°
    offsets.forEach(off=>{ ctx.beginPath(); ctx.moveTo(focusX + off, yLensPx - 120); ctx.lineTo(focusX, floorY); ctx.stroke(); });
    // èšç„¦äº®æ–‘ç•¥å°
    const grd = ctx.createRadialGradient(focusX, floorY, 0, focusX, floorY, 22);
    grd.addColorStop(0, 'rgba(255,250,180,0.85)'); grd.addColorStop(1, 'rgba(255,250,180,0.0)');
    ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(focusX, floorY, 22, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    return {focusOnFloor:true, focusX: focusX/p};
  }

  function drawRoach(xm, ym, scale=1, inverted=false, alpha=1, phase=0, t=0, tintColor=null, labelText=null, dead=false){
    const p = pxPerM(); const x = xm * p; const y = marginTop + ym * p;
    ctx.save(); ctx.translate(x, y);
    // dead: freeze wiggle
    const wigInput = dead ? 0 : Math.sin(t*6 + phase);
    ctx.scale(1, inverted ? -1 : 1); ctx.scale(scale*0.7, scale*0.7); ctx.globalAlpha = alpha;
    const bodyFill = dead ? '#b6bac4' : (tintColor || '#9aa3b0');
    ctx.fillStyle = bodyFill; ctx.strokeStyle = '#0a0e14'; ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.ellipse(0, 0, 18, 28, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.save(); ctx.translate(0, -26); ctx.rotate(wigInput*0.05);
    ctx.beginPath(); ctx.ellipse(0, 0, 10, 8, 0, 0, Math.PI*2); ctx.fillStyle = dead ? '#aab0be' : (tintColor ? bodyFill : '#8a93a0'); ctx.fill(); ctx.stroke(); ctx.restore();
    ctx.strokeStyle = 'rgba(0,0,0,0.35)'; for(let i=-18;i<=18;i+=6){ ctx.beginPath(); ctx.moveTo(-10, i); ctx.lineTo(10, i); ctx.stroke(); }
    ctx.strokeStyle = '#cfd7e6'; ctx.lineWidth = 1.1;
    for(let side of [-1,1]){ for(let i=0;i<3;i++){ const sway = (i%2===0?wigInput:-wigInput) * (3+i*0.7); ctx.beginPath(); ctx.moveTo(side*10, -8 + i*10); ctx.lineTo(side*(20+sway), -12 + i*10); ctx.lineTo(side*(26+sway*0.6), -6 + i*10); ctx.stroke(); } }
    ctx.beginPath(); ctx.moveTo(-4, -33); ctx.quadraticCurveTo(-14 - wigInput*6, -46 - wigInput*5, -26 - wigInput*10, -50); ctx.moveTo(4, -33); ctx.quadraticCurveTo(14 + wigInput*6, -46 - wigInput*5, 26 + wigInput*10, -50); ctx.strokeStyle = '#cfd7e6'; ctx.stroke();
    if (labelText){ ctx.save(); ctx.scale(1, inverted ? -1 : 1); ctx.globalAlpha = 0.95; ctx.fillStyle = '#ffd84d'; ctx.font = '10px system-ui'; ctx.fillText(labelText, -8, -38); ctx.restore(); }
    ctx.restore();
  }

  function drawGhostRoach(xm, ym, scale, inverted, blurPx, alpha=0.9){
    const off = document.createElement('canvas'); off.width = 200; off.height = 200; const octx = off.getContext('2d');
    octx.imageSmoothingEnabled = true; octx.translate(100,100); octx.globalAlpha = 1; drawRoachOffscreen(octx, scale, inverted);
    const p = pxPerM(); ctx.save();
    if (blurPx <= 0.0001){ ctx.filter = 'none'; ctx.globalAlpha = 1.0; }
    else { ctx.filter = `blur(${blurPx.toFixed(2)}px)`; ctx.globalAlpha = alpha; }
    ctx.drawImage(off, xm*p-100, marginTop + ym*p-100); ctx.filter = 'none'; ctx.restore();
  }
  function drawRoachOffscreen(g, scale=1, inverted=false){
    const t = performance.now()/1000; const phase=0; g.save(); g.scale(1, inverted ? -1 : 1); g.scale(scale*0.7, scale*0.7);
    const wig = Math.sin(t*6 + phase); g.fillStyle = '#cfd6e4'; g.strokeStyle = '#0a0e14'; g.lineWidth = 1.1;
    g.beginPath(); g.ellipse(0, 0, 18, 28, 0, 0, Math.PI*2); g.fill(); g.stroke();
    g.beginPath(); g.ellipse(0, -26, 10, 8, 0, 0, Math.PI*2); g.fill(); g.stroke();
    g.strokeStyle = 'rgba(0,0,0,0.35)'; for(let i=-18;i<=18;i+=6){ g.beginPath(); g.moveTo(-10,i); g.lineTo(10,i); g.stroke(); }
    g.strokeStyle = '#cfd7e6'; g.lineWidth=1.1; for(let side of [-1,1]){ for(let i=0;i<3;i++){ const sway = (i%2===0?wig:-wig) * (3+i*0.7); g.beginPath(); g.moveTo(side*10, -8 + i*10); g.lineTo(side*(20+sway), -12 + i*10); g.lineTo(side*(26+sway*0.6), -6 + i*10); g.stroke(); } }
    g.beginPath(); g.moveTo(-4,-33); g.quadraticCurveTo(-14 - wig*6, -46 - wig*5, -26 - wig*10, -50); g.moveTo(4,-33); g.quadraticCurveTo(14 + wig*6, -46 - wig*5, 26 + wig*10, -50); g.stroke(); g.restore();
  }

  function drawFocusCue(calc){
    const p = pxPerM(); ctx.save(); ctx.setLineDash([6,6]); ctx.lineWidth = 1.2;
    const tol = 0.02; // 2 cm å®¹å·®
    const err = calc.err;
    const blur = (err <= tol) ? 0 : Math.min(28, (err - tol) * 1400);
    const alpha = (err <= tol) ? 1.0 : 0.75;
    if (calc.sp_geom > 0){
      ctx.strokeStyle = (err <= tol) ? '#74ff9b' : '#ffaa74';
      ctx.beginPath(); ctx.moveTo(0, marginTop + H*p); ctx.lineTo(canvas.width/getDPR(), marginTop + H*p); ctx.stroke();
      drawGhostRoach(calc.x_img, H, Math.abs(calc.m), true, blur, alpha);
    } else {
      ctx.strokeStyle = (err <= tol) ? '#74ff9b' : '#ffaa74';
      ctx.beginPath(); ctx.moveTo(0, marginTop); ctx.lineTo(canvas.width/getDPR(), marginTop); ctx.stroke();
      drawGhostRoach(calc.x_img, 0, Math.abs(calc.m), false, blur, alpha);
    }
    ctx.restore();
  }

  function drawRays(calc){
    const p = pxPerM();
    const O = {x: roach.x, y: 0};
    const L = {x: lens.x, y: lens.y};
    const F1 = {x: lens.x, y: lens.y - lens.f};
    const F2 = {x: lens.x, y: lens.y + lens.f};

    const A_hit = {x: O.x, y: L.y};
    const A_dir = {x: F2.x - A_hit.x, y: F2.y - A_hit.y};
    const B_dir = {x: L.x - O.x, y: L.y - O.y};
    function intersectY(P, Q, y){ const t = (y - P.y) / (Q.y - P.y); return {x: P.x + t*(Q.x - P.x), y: y}; }
    const C_hit = intersectY(O, F1, L.y);

    function lineIntersect(P, v, Q, w){ const det = v.x * w.y - v.y * w.x; if (Math.abs(det) < 1e-6) return null; const t = ((Q.x - P.x) * w.y - (Q.y - P.y) * w.x) / det; return {x: P.x + t * v.x, y: P.y + t * v.y}; }
    const focusPoint = lineIntersect(A_hit, A_dir, L, B_dir);

    function toPX(pt){ return {x: pt.x * p, y: marginTop + pt.y * p}; }
    function strokeLine(P, Q, color, dash=null, width=1.6){ ctx.save(); if (dash) ctx.setLineDash(dash); ctx.strokeStyle = color; ctx.lineWidth = width; ctx.beginPath(); ctx.moveTo(P.x, P.y); ctx.lineTo(Q.x, Q.y); ctx.stroke(); ctx.restore(); }

    strokeLine(toPX({x:L.x,y:0}), toPX({x:L.x,y:H}), 'rgba(130,160,220,0.35)', [4,4], 1);
    strokeLine(toPX(O), toPX(A_hit), 'rgba(255,255,180,0.95)', null, 1.8);
    const A_far = {x: A_hit.x + A_dir.x * 6, y: A_hit.y + A_dir.y * 6}; strokeLine(toPX(A_hit), toPX(A_far), 'rgba(255,255,180,0.95)', null, 1.8);
    strokeLine(toPX(O), toPX(L), 'rgba(140,220,255,0.95)', null, 1.8);
    const B_far = {x: L.x + B_dir.x * 6, y: L.y + B_dir.y * 6}; strokeLine(toPX(L), toPX(B_far), 'rgba(140,220,255,0.95)', null, 1.8);
    strokeLine(toPX(O), toPX(C_hit), 'rgba(170,255,210,0.95)', null, 1.8);
    const C_far = {x: C_hit.x, y: C_hit.y + 6}; strokeLine(toPX(C_hit), toPX(C_far), 'rgba(170,255,210,0.95)', null, 1.8);

    if (calc.sp_geom < 0 && focusPoint){
      const A_back = {x: A_hit.x - A_dir.x * 6, y: A_hit.y - A_dir.y * 6}; strokeLine(toPX(A_hit), toPX(A_back), 'rgba(255,255,180,0.6)', [6,6], 1.4);
      const B_back = {x: L.x - B_dir.x * 6, y: L.y - B_dir.y * 6}; strokeLine(toPX(L), toPX(B_back), 'rgba(140,220,255,0.6)', [6,6], 1.4);
    }

    if (focusPoint){ const PF = toPX(focusPoint); ctx.save(); ctx.fillStyle = '#74ff9b'; ctx.strokeStyle = '#16351f'; ctx.beginPath(); ctx.arc(PF.x, PF.y, 5, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore(); }
  }

  function registerFamily(fbin, a, b){
    if (!families.has(fbin)){
      const makeParent = (p)=>({ sex: p.sex, f_cm: fbin, s_m: p.s_signed, sp_m: p.sp_signed, type: p.type, classText: classifyImage(p) });
      families.set(fbin, { f_cm:fbin, parents:[ makeParent(a), makeParent(b) ], babies:0 });
    }
  }

  function classifyImage(p){
    if (p.sp_signed < 0){ const mag = Math.abs(p.m); if (mag > 1) return 'æ”¾å¤§å¯¦åƒ'; if (mag < 1) return 'ç¸®å°å¯¦åƒ'; return 'ç­‰å¤§å¯¦åƒ'; }
    return 'æ”¾å¤§è™›åƒ';
  }

  function handlePairingAndBreeding(){
    const maxDist = 0.08; const minX = 0.4, maxX = Math.max(0.4, canvas.width/getDPR()/pxPerM()-0.4);
    for (let i=0;i<clones.length;i++){
      const a = clones[i]; if (a.isBaby || a.hasBirthed || a.dead) continue;
      for (let j=i+1;j<clones.length;j++){
        const b = clones[j]; if (b.isBaby || b.hasBirthed || b.dead) continue;
        if (a.focusBin!==b.focusBin) continue;
        if (!((a.sex==='F' && b.sex==='M') || (a.sex==='M' && b.sex==='F'))) continue;
        if (Math.abs(a.x - b.x) < maxDist && Math.abs(a.y - b.y) < 0.05){
          const xm = (a.x+b.x)/2, ym=(a.y+b.y)/2; hearts.push({x:xm, y:ym, t:0});
          a.status='toSide'; a.targetX=minX; b.status='toSide'; b.targetX=maxX; a.hasBirthed=true; b.hasBirthed=true;
          registerFamily(a.focusBin, a, b);
          spawnBabies(xm, ym, a.focusBin, a);
          checkWin();
        }
      }
    }
  }

  function spawnBabies(xm, ym, fbin, ref){
    if (!families.has(fbin)) registerFamily(fbin, ref, ref);
    const fam = families.get(fbin);
    for (let k=0;k<6;k++){
      const jitter = (Math.random()-0.5)*0.3; const dir = Math.random()<0.5?-1:1; const speed = 0.15 + Math.random()*0.2;
      clones.push({ x: xm + jitter, y: H, scale: 0.45 * (0.85 + Math.random()*0.3), dir, speed, phase: Math.random()*Math.PI*2, sex:'B', color:'#ffe766', alpha:0.6, f_cm:fbin, focusBin:fbin, status:'free', targetX:null, hasBirthed:true, isBaby:true, inverted:false, s_signed: ref.s_signed, sp_signed: ref.sp_signed, type: 'å°èŸ‘è‚', dead:false, deathT:0, corpseAlpha:1, corpseFading:false, hidden:false });
      fam.babies++;
    }
  }

  function checkWin(){
    const finishedKeys = [...families.keys()].filter(k=>families.get(k).babies>=6);
    if (finishedKeys.length >= 3){ const arr = finishedKeys.slice(0,3).map(k=>families.get(k)); showWin(arr); }
  }

  function showWin(familiesArr){
    let html = '<table><thead><tr><th>#</th><th>å®¶åº­(ç„¦æ®µ f, cm)</th><th>æ€§åˆ¥</th><th>ç‰©è· s (cm)</th><th>åƒè· s\' (cm)</th><th>åƒçš„æ€§è³ª</th></tr></thead><tbody>';
    let idx = 1;
    familiesArr.forEach((fam)=>{
      fam.parents.forEach((p)=>{
        const s_cm = (p.s_m*100).toFixed(1);
        const sp_cm = (p.sp_m*100).toFixed(1);
        html += `<tr><td>${idx++}</td><td>${fam.f_cm}</td><td>${p.sex==='F'?'æ¯(ç²‰ç´…)':'å…¬(ç¶ )'}</td><td>${s_cm}</td><td>${sp_cm}</td><td>${p.classText}</td></tr>`;
      });
    });
    html += '</tbody></table>';
    winSummary.innerHTML = html + '<p style="margin-top:8px;color:#cfdaf2;font-size:12px;">èªªæ˜ï¼šåˆ—è¡¨åªåŒ…å«ä¸‰å€‹å®¶åº­çš„çˆ¶æ¯å…±å…­éš»ï¼›ç„¦è·èˆ‡åƒè·çš†ä»¥ <b>cm</b> å‘ˆç¾ï¼›ä¸é¡¯ç¤ºæ”¾å¤§ç‡æ•¸å€¼ã€‚è¢«ç¼æ­»çš„å€‹é«”ä¸å½±éŸ¿æ­¤æ¸…å–®ã€‚</p>';
    winEl.style.display = 'flex';
  }

  function drawHeart(xm, ym, t){ const p = pxPerM(); const x = xm*p, y = marginTop + ym*p - t*10; const s = 10 + t*6; ctx.save(); ctx.translate(x,y); ctx.globalAlpha = 0.8*(1-t); ctx.fillStyle = '#ff6fa0'; ctx.beginPath(); ctx.moveTo(0, -s*0.2); ctx.bezierCurveTo(-s, -s, -s, s*0.3, 0, s); ctx.bezierCurveTo(s, s*0.3, s, -s, 0, -s*0.2); ctx.fill(); ctx.restore(); }

  // ---------- Main loop ----------
  let last = performance.now();
  function tick(t){
    const dt = Math.min(0.033, (t-last)/1000); last = t;
    const p = pxPerM();

    // original roach motion
    roach.phase += dt*6; roach.x += roach.dir * roach.speed * dt;
    const minX = 0.4, maxX = Math.max(0.4, canvas.width/getDPR()/p - 0.4);
    if (roach.x < minX) { roach.x = minX; roach.dir = 1; }
    if (roach.x > maxX) { roach.x = maxX; roach.dir = -1; }

    // clone motion & death update
    for (const c of clones){
      if (!c.dead){ c.phase += dt*6; c.x += c.dir * c.speed * dt; }
      if (c.status==='free'){
        if (c.x < minX) { c.x = minX; c.dir = 1; }
        if (c.x > maxX) { c.x = maxX; c.dir = -1; }
      } else if (c.status==='toSide' && c.targetX!==null){
        const sgn = Math.sign(c.targetX - c.x) || 1; c.x += sgn * c.speed * dt * 1.5; if (Math.abs(c.x - c.targetX) < 0.02) c.status='atSide';
      }
      if (c.dead){ c.deathT += dt; if (c.deathT > 0.7 && !c.soulSpawned){ souls.push({x:c.x, y:c.y, t:0, link:c}); c.soulSpawned=true; } if (c.corpseFading){ c.corpseAlpha = Math.max(0, c.corpseAlpha - dt*0.6); if (c.corpseAlpha<=0) c.hidden=true; } }
    }

    handlePairingAndBreeding();

    // draw
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const calc = computeImaging();
    drawWorldGrid();
    const focusInfo = drawBulbAndFocus(calc);
    drawRays(calc);

    // original roach (always alive,åœ¨å¤©èŠ±æ¿)
    drawRoach(roach.x, 0, 1.0, false, 1, roach.phase, t/1000, null, null, false);

    // kill check: only when focus on floor
    if (focusInfo.focusOnFloor){
      const killR = 0.06; // 6 cm radius
      for (const c of clones){
        if (c.dead) continue;
        if (Math.abs(c.y - H) < 1e-6 && Math.abs(c.x - focusInfo.focusX) < killR){ c.dead = true; c.phase = 0; }
      }
    }

    // draw clones
    for (const c of clones){
      if (c.hidden) continue;
      const label = c.isBaby ? `${c.f_cm}` : null;
      const alpha = c.dead ? Math.min(0.9, c.corpseAlpha) : c.alpha;
      const inv = c.dead ? !c.inverted : (c.inverted||false); // æ­»äº¡ï¼šç¿»èº«
      drawRoach(c.x, c.y, c.scale, inv, alpha, c.phase, t/1000, c.color, label, c.dead);
    }

    // draw souls
    for (let i=souls.length-1;i>=0;i--){
      const s = souls[i]; s.t += dt; s.y = Math.max(-0.2, s.y - dt*0.6); // rise 0.6 m/s, allow pass ceiling
      const px = s.x* p, py = marginTop + s.y * p;
      ctx.save(); ctx.globalAlpha = Math.max(0, 1 - s.t*0.8);
      ctx.strokeStyle = '#e7f1ff'; ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.beginPath(); ctx.ellipse(px, py - 10, 10, 14, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(px-6, py); ctx.lineTo(px+6, py); ctx.stroke();
      ctx.restore();
      if (s.y <= 0 && s.link && !s.link.corpseFading){ s.link.corpseFading = true; }
      if (s.t > 2.2 || s.y<=-0.05){ souls.splice(i,1); }
    }

    for (let i=hearts.length-1;i>=0;i--){ const h = hearts[i]; const dt2 = dt; h.t += dt2; drawHeart(h.x, h.y, h.t); if (h.t>0.8) hearts.splice(i,1); }

    drawLens();
    drawRuler(calc);
    drawFocusCue(calc); // æœ€å¾Œç•«ï¼Œé¿å…é®è”½è™›åƒ

    requestAnimationFrame(tick);
  }

  requestAnimationFrame(tick);

  // ---------- Readme loader ----------
  async function loadReadme(){
    try{
      const res = await fetch('readme.md', {cache:'no-store'});
      if (!res.ok) throw new Error('HTTP '+res.status);
      const text = await res.text();
      // ç°¡å–®å‘ˆç¾ï¼šç›´æ¥æ”¾å…¥ï¼Œä¿ç•™ Markdown åŸè²Œï¼›è‹¥åŒ…å« HTMLï¼Œå‡ºæ–¼å®‰å…¨ç”¨ textContent
      const safe = document.createElement('pre');
      safe.textContent = text;
      helpContent.innerHTML = '';
      helpContent.appendChild(safe);
    }catch(err){
      helpContent.textContent = 'ç„¡æ³•è¼‰å…¥ readme.mdï¼š' + err.message + '\nè«‹ç¢ºèªæª”æ¡ˆå­˜åœ¨æ–¼ç›¸åŒè³‡æ–™å¤¾ã€‚';
    }
  }

  // ---------- Tests ----------
  function approx(a,b,eps=1e-6){ return Math.abs(a-b) <= eps; }
  function runTests(){
    const badge = document.getElementById('testBadge');
    const saved = { lens: { ...lens }, roach: { ...roach } };

    // Case 1: s=1.5m, f=0.5m â†’ s' = 0.75m (å¯¦åƒ)
    lens.y = 1.5; roach.y = 0; lens.f = 0.5; let c = computeImaging();
    let expected_sp = 1/(1/lens.f - 1/(lens.y - roach.y));
    console.assert(approx(c.sp_geom, expected_sp, 1e-9), 'Test1 sp_geom');
    console.assert(approx(c.m, -c.sp_geom/(lens.y - roach.y)), 'Test1 magnification');

    // Case 2: s=0.3m, f=0.5m â†’ s' < 0 (è™›åƒ)
    lens.y = 0.3; roach.y = 0; lens.f = 0.5; c = computeImaging();
    console.assert(c.sp_geom < 0, 'Test2 virtual image');

    // Focus kill gate
    lens.y = H - 0.5; lens.f = 0.5; const diff = Math.abs((H - lens.y) - lens.f); console.assert(diff < 1e-9, 'Test3 focus gate');

    // New: ensure drawLens exists and is callable
    console.assert(typeof drawLens === 'function', 'Test4 drawLens present');

    // New: ensure readme loader exists & help container present
    console.assert(typeof loadReadme === 'function', 'Test5 loadReadme present');
    console.assert(!!document.getElementById('helpContent'), 'Test6 helpContent exists');

    // Restore
    lens = saved.lens; Object.assign(roach, saved.roach);

    badge.style.display = 'block'; setTimeout(()=>{ badge.style.display='none'; }, 1800);
  }
  setTimeout(()=>runTests(), 120); // ensure scheduled after potential readme load hook is defined
})();
</script>
</body>
</html>
