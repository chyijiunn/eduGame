<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>模式螞蟻費洛蒙策略遊戲 v0.6.4</title>
<style>
  :root { --bg:#0f1115; --panel:#151922; --ink:#e8eefc; --muted:#9aa4b2; --accent:#77e4a0; --danger:#ff7a7a; --warn:#ffd36e; }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, PingFangTC, "Noto Sans TC", Segoe UI, Roboto, Helvetica, Arial;}
  #wrap{display:grid; grid-template-columns: 1fr 300px; gap:8px; height:100vh; padding:8px; box-sizing:border-box;}
  #stage{position:relative; width:100%; height:100%;}
  #canvas{position:absolute; inset:0; background:#0b0d12; border:1px solid #22283a; border-radius:12px; width:100%; height:100%; display:block; image-rendering:pixelated}
  #panel{background:var(--panel); border-radius:12px; padding:10px; overflow:auto; display:grid; gap:8px}
  .slot{background:#101625; border:1px solid #2b3246; border-radius:10px; padding:8px; display:flex; align-items:center; gap:8px; justify-content:space-between}
  .col{display:flex; flex-direction:column; gap:8px; width:100%}
  .row{display:flex; gap:6px; align-items:center; flex-wrap:wrap}
  button,select{background:#23293a; color:var(--ink); border:1px solid #2b3246; border-radius:10px; padding:6px 10px; cursor:pointer}
  button:hover{filter:brightness(1.08)}
  .pill{border:1px solid #334; border-radius:30px; padding:4px 8px; font-size:12px}
  .badge{font-size:11px; padding:2px 6px; border-radius:8px; background:#223}
  .mini{font-size:12px; color:var(--muted)}
  #wxBox{display:flex; align-items:center; gap:8px}
  #wxArrow{width:160px; height:42px; background:#0c1020; border:1px solid #2b3246; border-radius:8px}
  #clock{width:120px; height:120px; background:#0c1020; border:1px solid #2b3246; border-radius:60px}
  #errorOverlay{position:fixed; right:12px; bottom:12px; display:none; z-index:9999; background:#1d2233; color:#ffd1d1; border:1px solid #b44; border-radius:12px; padding:12px; box-shadow:0 6px 30px #0008; max-width:40vw}
  #errorOverlay pre{white-space:pre-wrap; font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; color:#ffd1d1}
  table{width:100%; border-collapse:collapse; font-size:13px}
  th,td{border-bottom:1px solid #2b3246; padding:6px 8px; text-align:left; vertical-align:top}
</style>
</head>
<body>
  <div id="wrap">
    <div id="stage"><canvas id="canvas"></canvas></div>
    <div id="panel">
      <!-- Weather -->
      <div class="slot">
        <b>天氣</b>
        <div id="wxBox">
          <canvas id="wxArrow" width="160" height="42"></canvas>
          <div class="mini" id="wxText">—</div>
        </div>
      </div>
      <!-- Level / controls -->
      <div class="slot"><b>關卡</b>
        <span class="row">
          <select id="levelSel"><option value="1">Lv1</option><option value="2">Lv2</option><option value="3">Lv3</option><option value="4">Lv4</option></select>
          <button id="btnRestart">重新開始</button>
          <button id="btnRef">ref</button>
        </span>
      </div>
      <div class="slot">
        <span>🎯 <span id="goalText"></span></span>
        <span id="timerWrap" style="display:none">⏱ <span id="timerText">0</span>s</span>
      </div>
      <!-- Merged stats -->
      <div class="slot col">
        <b>概況</b>
        <table id="mergedTable"><thead><tr><th>分類</th><th>項目</th><th>數值</th></tr></thead><tbody></tbody></table>
      </div>
      <!-- Materials & crafting -->
      <div class="slot col">
        <b>材料</b>
        <div id="matRow" class="row"></div>
        <div class="row" style="justify-content:space-between">
          <span class="row"><b>合成</b> <select id="craftSel"></select></span>
          <button id="btnCraft">+1</button>
        </div>
        <div class="slot" style="background:#0e1424; width:100%; justify-content:flex-start">
          <b>瓶庫</b><div id="invList" class="row" style="margin-left:6px"></div>
        </div>
      </div>
      <!-- Speed clock -->
      <div class="slot col">
        <b>速度</b>
        <div class="row" style="justify-content:space-between;width:100%">
          <div class="row"><button id="speedDown">−</button><button id="speedUp">＋</button></div>
          <div class="mini">目前：<span id="speedLabel">1×</span></div>
        </div>
        <canvas id="clock" width="120" height="120" title="點選 + / − 調整速度"></canvas>
      </div>
      <!-- View -->
      <div class="slot col">
        <b>視圖</b>
        <div class="row">
          <button id="btnZoomIn">＋</button>
          <button id="btnZoomOut">－</button>
          <button id="btnZoomReset">1:1</button>
        </div>
      </div>
      <div id="nextActions" class="slot" style="display:none; justify-content:flex-start; gap:8px">
        <b id="nextLabel"></b>
        <button id="btnNext" style="display:none"></button>
        <button id="btnAddEnemy" style="display:none">新增敵人</button>
      </div>
    </div>
  </div>

  <div id="refModal" style="position:fixed; inset:0; display:none; place-items:center; background:#0008"><div id="refCard" style="width:min(1040px,94vw); height:min(84vh,760px); background:#111522; border:1px solid #2b3246; border-radius:14px; overflow:auto; padding:16px"></div></div>
  <div id="errorOverlay"><b>⚠️ 腳本錯誤</b><pre id="errorText"></pre></div>

<script>
'use strict';
/*********** Canvas helpers ***********/
CanvasRenderingContext2D.prototype._rr = function(x,y,w,h,r){
  if(this.roundRect){ this.roundRect(x,y,w,h,r); return; }
  r = Math.min(r, w/2, h/2);
  this.beginPath(); this.moveTo(x+r, y);
  this.arcTo(x+w, y, x+w, y+h, r);
  this.arcTo(x+w, y+h, x, y+h, r);
  this.arcTo(x, y+h, x, y, r);
  this.arcTo(x, y, x+w, y, r); this.closePath();
};
function rr(o,x,y,w,h,r){ o._rr(x,y,w,h,r); o.fill(); o.stroke(); }
function drawArrow(o,x,y,len,ang,color){ o.save(); o.translate(x,y); o.rotate(ang); o.strokeStyle=color; o.lineWidth=2; o.beginPath(); o.moveTo(0,0); o.lineTo(len,0); o.stroke(); o.beginPath(); o.moveTo(len,0); o.lineTo(len-6, 3); o.lineTo(len-6, -3); o.closePath(); o.fillStyle=color; o.fill(); o.restore(); }

/*********** Data: ref & chemistry ***********/
const REF=[
  {id:'m4mp2c',short:'吡咯酸甲酯',formal:'methyl 4-methylpyrrole-2-carboxylate',cls:'路徑-短',source:'毒腺',mw:169},
  {id:'edp',short:'乙基二甲基吡嗪（EDP）',formal:'3-ethyl-2,5-dimethylpyrazine',cls:'路徑/警戒',source:'毒腺',mw:136},
  {id:'faranal',short:'Faranal',formal:'faranal',cls:'路徑-長',source:'杜佛氏腺',mw:208},
  {id:'mono1',short:'Monomorine I',formal:'monomorine I',cls:'招募-短',source:'毒腺',mw:195},
  {id:'noentry',short:'禁止混合物',formal:'no-entry blend',cls:'禁止',source:'毒腺',mw:160},
  {id:'formic',short:'蟻酸',formal:'formic acid',cls:'防禦',source:'毒腺',mw:46},
  {id:'c11',short:'十一烷',formal:'n-undecane',cls:'增效',source:'杜佛氏腺/毒腺',mw:156},
  {id:'farnesene',short:'α-法呢烯',formal:'(Z,E)-α-farnesene',cls:'招募',source:'杜佛氏腺',mw:204},
  {id:'dolich',short:'多利克二醛',formal:'dolichodial',cls:'路徑',source:'腹端腺',mw:236},
  {id:'irido',short:'Iridomyrmecin',formal:'iridomyrmecin',cls:'路徑',source:'腹端腺',mw:168},
  {id:'z9',short:'Z9-16 醛',formal:'(Z)-9-hexadecenal',cls:'增益',source:'腹端腺',mw:240}
];
const MATERIALS=['C','O','N','R','T','Ald','Acid','HC','LAC'];
const RECIPES={m4mp2c:{label:'吡咯酸甲酯',cost:{C:1,O:1,N:1}}, edp:{label:'乙基二甲基吡嗪',cost:{N:2,R:1,C:1}}, faranal:{label:'Faranal',cost:{T:2,Ald:1,HC:1}}, mono1:{label:'Monomorine I',cost:{N:1,R:1,HC:1}}, noentry:{label:'禁止混合物',cost:{Ald:1,Acid:1,HC:1}}, formic:{label:'蟻酸',cost:{Acid:2}}, c11:{label:'十一烷',cost:{HC:2}}, farnesene:{label:'α-法呢烯',cost:{T:2,HC:1}}, dolich:{label:'多利克二醛',cost:{Ald:2,R:1}}, irido:{label:'Iridomyrmecin',cost:{LAC:1,T:1}}, z9:{label:'Z9-16 醛',cost:{Ald:1,HC:1}}};

const TILE=16; let W=64, H=48; let WORLD_W=W*TILE, WORLD_H=H*TILE;
let level=1; let timeLeft=0; let showTimer=false;
let viewScale=1.0, viewX=0, viewY=0, timeScale=1.0;
const T_EMPTY=0, T_WATER=1, T_FOOD=2, T_NEST_ME=3, T_NEST_RIVAL=4, T_WALL=5, T_TARGET=7;

const PH={};
for(const r of REF){
  const baseHalf = 60; // minimum 60s at 1x
  // Heavier → longer; map MW 46..240 → 60..180 seconds
  const half = baseHalf + (Math.max(46, Math.min(240, r.mw)) - 46) * (120/(240-46));
  PH[r.id] = {type: (r.id==='noentry'?'ban': r.id==='formic'?'acid': (r.id==='mono1'||r.id==='farnesene')?'recruit':'trail'),
              color: (r.id==='noentry')?'#f77': (r.id==='formic')?'#f55': (r.id==='faranal')?'#6fa':
                     (r.id==='c11')?'#fc8': (r.id==='farnesene')?'#dff76a': (r.id==='irido')?'#c7f': (r.id==='dolich')?'#a5f': (r.id==='z9')?'#fff38a':'#9bf',
              strength: (r.id==='noentry'||r.id==='formic')?3:2,
              halfLifeSec: half };
}

/*********** Canvas & state ***********/
const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d');
function resizeCanvas(){ const rect=canvas.getBoundingClientRect(); const dpr=window.devicePixelRatio||1; canvas.width=Math.max(1, Math.floor(rect.width*dpr)); canvas.height=Math.max(1, Math.floor(rect.height*dpr)); }
window.addEventListener('resize', resizeCanvas);

let grid=[], scoreMe=0, scoreRival=0; let ants=[], antsRival=[]; let carrying=0; let mats={}, inventory={}, unlocked=[], selectedPh=null;
let colonyCap=40, colonyMax=Infinity, spawnBudget=0, rivalSpawn=150;
let wx={wind:1.2, windDir:0, humidIdx:3, raining:false, tDir:0};
let targets=[]; let enemies=[];

/*********** Utilities ***********/
function inBounds(x,y){ return x>=0&&y>=0&&x<W&&y<H; } function idx(x,y){ return y*W+x; }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; } function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); } function clone(obj){ return JSON.parse(JSON.stringify(obj)); }

/*********** Offscreen sprites (ants & foods) ***********/
const SCALE=8; const ANT_W=6, ANT_H=4;
const frames={antsMe:[], antsRv:[], food:{}};
function mkAnt(phase,flip,stroke){ const off=document.createElement('canvas'), o=off.getContext('2d'); off.width=ANT_W*SCALE; off.height=ANT_H*SCALE; o.scale(SCALE,SCALE); o.lineWidth=0.9; o.strokeStyle=stroke; o.translate(ANT_W/2,ANT_H/2); if(flip) o.scale(-1,1); o.translate(-ANT_W/2,-ANT_H/2);
  o.beginPath(); o.ellipse(1.6,2,1.6,1.2,0,0,Math.PI*2); o.ellipse(3.4,2,1.2,1.0,0,0,Math.PI*2); o.ellipse(4.8,2,0.9,0.9,0,0,Math.PI*2); o.stroke();
  const A=0.6; for(let i=0;i<3;i++){ const p=phase?1:-1, bx=[1.4,3.0,4.4][i], by=2; const a1=(i*0.6 + p*A), a2=(i*0.6 - p*A);
    o.beginPath(); o.moveTo(bx,by-0.4); o.lineTo(bx+Math.cos(a1)*1.5,by-0.4+Math.sin(a1)*1.5); o.stroke();
    o.beginPath(); o.moveTo(bx,by+0.4); o.lineTo(bx+Math.cos(a2)*1.5,by+0.4+Math.sin(a2)*1.5); o.stroke(); }
  o.beginPath(); o.moveTo(5.3,1.3); o.lineTo(6,0.5); o.moveTo(5.3,2.7); o.lineTo(6,3.3); o.stroke(); return off; }
frames.antsMe.push(mkAnt(0,0,"#9ffcac"),mkAnt(1,0,"#9ffcac"),mkAnt(0,1,"#9ffcac"),mkAnt(1,1,"#9ffcac"));
frames.antsRv.push(mkAnt(0,0,"#cfd3da88"),mkAnt(1,0,"#cfd3da88"),mkAnt(0,1,"#cfd3da88"),mkAnt(1,1,"#cfd3da88"));

/*********** Food fragments ***********/
function makeFood(kind){
  // Each food cell holds many fragments (positions, size)
  const baseCount = randInt(4,8);
  const frags=[];
  for(let i=0;i<baseCount;i++){
    const r = Math.random()*4 + 2; // px radius at base scale
    const ox = (Math.random()*0.6 - 0.3) * (TILE-6);
    const oy = (Math.random()*0.6 - 0.3) * (TILE-6);
    frags.push({ox,oy,r});
  }
  const yieldMap = (kind==='sugar')?{O:2,C:1} :
                   (kind==='peanut')?{C:2,R:1} :
                   (kind==='fish')?{N:2,C:1} :
                   (kind==='resin')?{T:2,C:1} :
                   (kind==='citrus')?{Ald:1,O:1,R:1} :
                   (kind==='oil')?{HC:2,C:1} :
                   (kind==='berry')?{Acid:2,O:1} :
                   (kind==='wax')?{HC:2} :
                   (kind==='chitin')?{N:1,Acid:1,R:1} : {C:1};
  return {type:kind, frags:frags, yield:yieldMap};
}
function drawFood(x,y,food){
  const cx=x*TILE+TILE/2, cy=y*TILE+TILE/2;
  for(const f of food.frags){
    const col = (food.type==='sugar')?'#ffe9a6' :
                (food.type==='peanut')?'#caa86d' :
                (food.type==='fish')?'#88b7ff' :
                (food.type==='resin')?'#f6c84a' :
                (food.type==='citrus')?'#ffa94d' :
                (food.type==='oil')?'#c7ffd1' :
                (food.type==='berry')?'#ff7aa8' :
                (food.type==='wax')?'#ffd36e' :
                (food.type==='chitin')?'#b9d4ff' : '#ddd';
    ctx.fillStyle=col; ctx.strokeStyle="#ffffffaa"; ctx.lineWidth=1;
    ctx.beginPath(); ctx.ellipse(cx+f.ox, cy+f.oy, f.r, f.r*0.7, 0.3, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  }
}

/*********** Weather ***********/
function rndSign(){ return Math.random()<0.5?-1:1; }
function stepWeather(dt){
  const mean=1.2, k=0.9;
  wx.wind = clamp(wx.wind + (mean - wx.wind)*k*dt + (Math.random()-0.5)*0.6*dt, 0, 4.0);
  wx.tDir += dt; if(wx.tDir>=30){ wx.windDir = (wx.windDir + (Math.random()*300 - 150)) % 360; wx.tDir=0; }
  if(Math.random()<0.02*dt){ wx.humidIdx = clamp(wx.humidIdx + rndSign()*1, 0, 6); }
  wx.raining = (wx.humidIdx===6 && wx.wind>3.2);
  const humidText=['極乾','很乾','偏乾','中等','偏濕','很濕','極濕'][wx.humidIdx];
  const t = document.getElementById('wxText'); if(t) t.textContent = '風 ' + wx.wind.toFixed(1) + ' m/s @ ' + wx.windDir.toFixed(0) + '°｜濕度 ' + humidText + (wx.raining?'｜🌧 下雨':'');
  drawWxArrow();
}
function drawWxArrow(){
  const c=document.getElementById('wxArrow'); if(!c) return; const o=c.getContext('2d'); o.setTransform(1,0,0,1,0,0); o.clearRect(0,0,c.width,c.height);
  const cx=18, cy=c.height/2; const len = 24 + wx.wind*18; const ang = wx.windDir * Math.PI/180;
  o.strokeStyle="#283049"; o.beginPath(); o.moveTo(2,cy); o.lineTo(c.width-2,cy); o.stroke();
  drawArrow(o, cx, cy, len, ang, "#9aa4b2");
  o.fillStyle="#9aa4b2"; o.font="12px ui-sans-serif"; o.fillText(wx.wind.toFixed(1)+" m/s", cx+len+8, cy+4);
}

/*********** Map generation with round water pools ***********/
function baseRandomMap(){
  grid=new Array(W*H).fill(0).map(function(){return {type:T_EMPTY, food:null, pherMe:{}, pherRv:{}, sniff:0, owner:null, control:0};});
  const pools = randInt(3,6);
  for(let i=0;i<pools;i++){
    const cx=randInt(6, W-7), cy=randInt(6, H-7);
    const r = randInt(3,6);
    for(let y=cy-r-1; y<=cy+r+1; y++){
      for(let x=cx-r-1; x<=cx+r+1; x++){
        if(!inBounds(x,y)) continue;
        const dx=x-cx, dy=y-cy; const d=Math.sqrt(dx*dx+dy*dy) + (Math.random()*0.8-0.4);
        if(d < r) grid[idx(x,y)].type=T_WATER;
      }
    }
  }
}
function randomNest(){ return {x:randInt(2,W-3), y:randInt(2,H-3)}; }
function placeNestsRandom(){ const a=randomNest(); const b=randomNest(); grid[idx(a.x,a.y)].type=T_NEST_ME; grid[idx(b.x,b.y)].type=T_NEST_RIVAL; }
function placeNestsCorners(){ grid[idx(2,2)].type=T_NEST_ME; grid[idx(W-3,H-3)].type=T_NEST_RIVAL; }
function scatterFood(list,count){
  for(let i=0;i<count;i++){
    const x=randInt(2,W-3), y=randInt(2,H-3);
    if(grid[idx(x,y)].type===T_EMPTY){
      const kind = choice(list);
      grid[idx(x,y)].type=T_FOOD; grid[idx(x,y)].food=makeFood(kind);
    }
  }
}
function spawnTargets(n){
  targets=[];
  for(let i=0;i<n;i++){
    const x=randInt(4,W-5), y=randInt(4,H-5);
    if(grid[idx(x,y)].type===T_EMPTY){
      grid[idx(x,y)].type=T_TARGET; grid[idx(x,y)].owner=null; grid[idx(x,y)].control=0;
      targets.push({x,y});
    } else { i--; }
  }
}

/*********** Levels ***********/
function setGoal(t){ const g=document.getElementById('goalText'); if(g) g.textContent=t; const tw=document.getElementById('timerWrap'); if(tw) tw.style.display = showTimer ? 'inline-flex' : 'none'; }
function makeMap_Lv1(){ baseRandomMap(); placeNestsCorners(); scatterFood(['sugar','peanut','fish'], 22); setGoal('Lv1：搬回顆粒數量要超過對手。'); showTimer=false; colonyCap=30; colonyMax=500; timeLeft=0; }
function makeMap_Lv2(){ baseRandomMap(); placeNestsRandom(); scatterFood(['resin','citrus','oil'], 18); spawnTargets(4); setGoal('Lv2：限時佔領控制點。'); showTimer=true; timeLeft=160; colonyCap=60; colonyMax=Infinity; }
function makeMap_Lv3(){ baseRandomMap(); placeNestsCorners(); scatterFood(['berry','wax','chitin'], 18); setGoal('Lv3：敵人可被擊敗轉為食物。'); showTimer=true; timeLeft=150; colonyCap=80; colonyMax=Infinity; enemies=[]; enemies.push(makeEnemy('spider'), makeEnemy('spider'), makeEnemy('gecko'), makeEnemy('roach')); }
function makeMap_Lv4(){ baseRandomMap(); placeNestsCorners(); scatterFood(['resin','citrus','oil'], 18); setGoal('Lv4：吸引＋禁止導引示意。'); showTimer=true; timeLeft=160; colonyCap=60; colonyMax=Infinity; }

/*********** Enemies (simplified) ***********/
function makeEnemy(kind){ const base = { kind, x:randInt(8,W-8)*TILE, y:randInt(8,H-8)*TILE, aim:Math.random()*Math.PI*2, hp:24, speed:24, alive:true, scale:1.6 }; if(kind==='gecko'){ base.hp=36; base.speed=22; base.scale=1.8; } if(kind==='roach'){ base.hp=28; base.speed=28; base.scale=1.5; } return base; }
function stepEnemies(dt){ for(let e of enemies){ if(!e.alive) continue; if(Math.random()<0.05) e.aim += (Math.random()-0.5)*0.8; const dx=Math.cos(e.aim)*e.speed*dt, dy=Math.sin(e.aim)*e.speed*dt; let nx=e.x+dx, ny=e.y+dy; const gx=Math.floor(nx/TILE), gy=Math.floor(ny/TILE); if(!inBounds(gx,gy) || grid[idx(gx,gy)].type===T_WATER){ e.aim += Math.PI*0.6; continue; } e.x=nx; e.y=ny; function combat(list){ for(const a of list){ const d=Math.hypot(a.x-e.x,a.y-e.y); if(d<12*e.scale){ e.hp -= 3*dt; if(Math.random()<0.12*dt){ a.hp -= 1; if(a.hp<=0){ a.alive=false; } } } } } combat(ants); combat(antsRival); if(e.hp<=0){ e.alive=false; const gx2=Math.floor(e.x/TILE), gy2=Math.floor(e.y/TILE); if(inBounds(gx2,gy2) && grid[idx(gx2,gy2)].type===T_EMPTY){ const sizeYield = Math.max(1, Math.round(3*e.scale)); grid[idx(gx2,gy2)].type=T_FOOD; grid[idx(gx2,gy2)].food=makeFood('fish'); } showNextAction('敵人被擊敗！', null, true); } } ants = ants.filter(a=>a.alive!==false); antsRival = antsRival.filter(a=>a.alive!==false); }

/*********** Pheromones ***********/
function placePher(x,y,key,amt,team){ if(!inBounds(x,y)) return; const c=grid[idx(x,y)]; if([T_WATER,T_WALL].includes(c.type)) return; const bucket=(team==='rv'?c.pherRv:c.pherMe); const windRad=(wx.windDir*Math.PI/180); const boost=1 + Math.max(0,Math.cos(windRad))*(wx.wind/3.5)*0.6; bucket[key]=(bucket[key]||0)+amt*boost; }
function localTrailStrength(gx,gy,team){ if(!inBounds(gx,gy)) return 0; const p=(team==='rv'?grid[idx(gx,gy)].pherRv:grid[idx(gx,gy)].pherMe)||{}; let s=0; for(const k in p){ const t=PH[k].type; if(t==='trail'||t==='recruit') s+=p[k]; } return s; }
function sniffAt(x,y){ if(!inBounds(x,y)) return; const c=grid[idx(x,y)]; c.sniff=(c.sniff||0)+1; if(c.sniff%30===0){ for(const k in c.pherMe){ c.pherMe[k]*=0.9; } for(const k in c.pherRv){ c.pherRv[k]*=0.9; } } }
function stepPher(dt){ for(let i=0;i<grid.length;i++){ const c=grid[i]; function decay(p){ for(const k in p){ const humidScale=[1.4,1.25,1.12,1.0,0.92,0.86,0.8][wx.humidIdx]; const half = PH[k].halfLifeSec * humidScale; const lambda = Math.LN2 / half; p[k] *= Math.exp(-lambda * dt); if(wx.raining) p[k]*=Math.exp(-dt*0.6); if(p[k]<0.01) delete p[k]; } } decay(c.pherMe); decay(c.pherRv); } }

/*********** Ants ***********/
function findNest(team){ for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ const t=grid[idx(x,y)].type; if(team==='me'&&t===T_NEST_ME) return {x:x,y:y}; if(team==='rv'&&t===T_NEST_RIVAL) return {x:x,y:y}; } } return {x:1,y:1}; }
function spawnAnt(team){ const n=findNest(team); const px=n.x*TILE+TILE/2, py=n.y*TILE+TILE/2; const aim=Math.random()*Math.PI*2; return {team:team, x:px, y:py, aim:aim, speed:26+Math.random()*10, sinceSig:0, sinceSteps:0, changeAt:(3+Math.random()*2)*ANT_H, carry:false, load:null, cool:0, hp:3, phCharge:4, phMax:6, dropCooldown:0, lastX:px, lastY:py, stuckT:0}; }
function signalMass(team){ let s=0; for(let i=0;i<grid.length;i++){ const p=team==='me'?grid[i].pherMe:grid[i].pherRv; if(!p) continue; for(const k in p){ const t=PH[k].type; if(t==='trail'||t==='recruit') s+=p[k]*2; } } return s; }
function desiredPopulation(){ const k=0.05; return Math.min(colonyMax, colonyCap + Math.floor(k*signalMass('me'))); }
function tryMoveAnt(a, dt){
  // attempt movement with obstacle avoidance up to 4 tries
  for(let t=0;t<4;t++){
    const dx=Math.cos(a.aim)*a.speed*dt, dy=Math.sin(a.aim)*a.speed*dt;
    const nx=a.x+dx, ny=a.y+dy; const gx=Math.floor(nx/TILE), gy=Math.floor(ny/TILE);
    if(inBounds(gx,gy) && grid[idx(gx,gy)].type!==T_WATER && grid[idx(gx,gy)].type!==T_WALL){ a.x=nx; a.y=ny; return true; }
    a.aim += (Math.random()-0.5)*Math.PI; // bounce
  }
  return false;
}
function stepAnt(a, dt){
  a.sinceSteps += dt*a.speed; const need = a.changeAt;
  a.dropCooldown = Math.max(0, a.dropCooldown - dt);
  const moved = Math.hypot(a.x-(a.lastX||a.x), a.y-(a.lastY||a.y));
  if(moved < 0.15){ a.stuckT = (a.stuckT||0) + dt; } else { a.stuckT = 0; }
  a.lastX=a.x; a.lastY=a.y;

  const gx=Math.floor(a.x/TILE), gy=Math.floor(a.y/TILE);
  const sig=(function(){ if(!inBounds(gx,gy)) return 0; const p=(a.team==='rv'?grid[idx(gx,gy)].pherRv:grid[idx(gx,gy)].pherMe)||{}; let A=0,R=0; for(const k in p){ const t=PH[k].type, v=p[k]; if(t==='ban'||t==='acid') R+=v*3; if(t==='trail'||t==='recruit') A+=v*2; } return A-R; })();
  if(sig>0.02){ a.sinceSteps=0; }

  const nest=findNest(a.team);

  if(a.carry){
    const nx=nest.x*TILE+TILE/2, ny=nest.y*TILE+TILE/2; const ang=Math.atan2(ny-a.y, nx-a.x);
    // Add small wander, but keep bias to nest
    a.aim = ang + (Math.random()-0.5)*0.12;
    if(a.dropCooldown<=0 && a.phCharge>0 && localTrailStrength(gx,gy,a.team) < 0.3){
      placePher(gx,gy, 'm4mp2c', 0.5, a.team);
      a.phCharge -= 1; a.dropCooldown = 0.20;
    }
    // Anti-stuck boost while carrying
    if(a.stuckT>0.6){ a.aim += (Math.random()-0.5)*Math.PI; a.speed *= 1.12; a.stuckT=0; }
  }else{
    if(a.sinceSteps > need && sig<=0.02){
      a.sinceSteps=0; a.aim += (Math.random()-0.5)*Math.PI;
    }else if(sig>0.02){
      a.aim += (Math.random()-0.5)*0.08;
    }
  }

  if(!tryMoveAnt(a, dt)) return;

  sniffAt(gx,gy);
  const cell=grid[idx(gx,gy)];
  if(!a.carry && cell.type===T_FOOD && cell.food.frags.length>0){
    a.carry=true; carrying++; a.load = clone(cell.food.yield);
    a.phCharge = Math.min(a.phMax, a.phCharge + 2);
    // remove one fragment (the smallest first to show "碎塊化")
    cell.food.frags.sort((u,v)=>u.r-v.r);
    const taken = cell.food.frags.shift();
    if(!cell.food.frags.length){ cell.type=T_EMPTY; cell.food=null; placePher(gx,gy,'noentry',1.2,a.team); }
    if(a.phCharge>0){ placePher(gx,gy, 'm4mp2c', 1.0, a.team); a.phCharge -= 1; }
    if(a.team==='me'){ colonyCap = Math.min(colonyMax, colonyCap + 1); }
  }
  if(a.carry && gx===nest.x && gy===nest.y){
    a.carry=false; carrying=Math.max(0,carrying-1);
    if(a.team==='me'){ scoreMe++; if(a.load){ for(const k in a.load){ mats[k]=(mats[k]||0)+a.load[k]; } refreshMats(); } } else { scoreRival++; }
    a.load=null;
    if(a.phCharge>0){ placePher(gx,gy, 'm4mp2c', 0.4, a.team); a.phCharge -= 1; }
    a.phCharge = a.phMax; // refill at nest
  }
}

/*********** HUD / Ref / UI ***********/
function refreshMats(){ const row=document.getElementById('matRow'); if(!row) return; row.innerHTML=''; for(const k of MATERIALS){ const d=document.createElement('div'); d.className='pill'; d.textContent=k+': '+(mats[k]||0); row.appendChild(d);} }
function refreshInv(){ const list=document.getElementById('invList'); if(!list) return; list.innerHTML=''; for(const id of unlocked){ const btn=document.createElement('button'); btn.textContent=(RECIPES[id]&&RECIPES[id].label)||id; btn.title='剩餘 '+(inventory[id]||0); btn.onclick=function(){ selectedPh=id; }; list.appendChild(btn); const badge=document.createElement('span'); badge.className='badge'; badge.textContent=inventory[id]||0; list.appendChild(badge);} }
function buildCraftSel(){ const sel=document.getElementById('craftSel'); if(!sel) return; sel.innerHTML=''; for(const id of unlocked){ const opt=document.createElement('option'); opt.value=id; opt.textContent=(RECIPES[id]&&RECIPES[id].label)||id; sel.appendChild(opt);} }
document.getElementById('btnCraft').onclick=function(){ const id=document.getElementById('craftSel').value; const need=RECIPES[id].cost; for(const k in need){ if((mats[k]||0)<need[k]) return; } for(const k in need) mats[k]-=need[k]; inventory[id]=(inventory[id]||0)+1; refreshInv(); refreshMats(); };
function updateHud(){
  const tbody=document.querySelector('#mergedTable tbody'); if(!tbody) return; tbody.innerHTML='';
  function row(cat,item,val){ const tr=document.createElement('tr'); tr.innerHTML='<td>'+cat+'</td><td>'+item+'</td><td>'+val+'</td>'; tbody.appendChild(tr); }
  const meCarry = ants.reduce((n,a)=>n+(a.carry?1:0),0);
  const rvCarry = antsRival.reduce((n,a)=>n+(a.carry?1:0),0);
  row('我方','螞蟻數', ants.length); row('我方','搬運中', meCarry); row('我方','得分', scoreMe);
  row('敵方','螞蟻數', antsRival.length); row('敵方','搬運中', rvCarry); row('敵方','得分', scoreRival);
  const agg={}; for(let i=0;i<grid.length;i++){ const c=grid[i]; if(c.type===T_FOOD){ const k=c.food.type; if(!agg[k]) agg[k]={cnt:0,rem:0}; agg[k].cnt++; agg[k].rem+=c.food.frags.length; } }
  for(const k of Object.keys(agg)){ row('食物', k, '堆數 '+agg[k].cnt+'｜碎塊 '+agg[k].rem); }
}

/*********** Ref modal (same content as before, compact) ***********/
function openRef(){
  const modal=document.getElementById('refModal'); const card=document.getElementById('refCard');
  let phRows=''; for(const r of REF){ phRows+='<tr><td>'+r.short+'</td><td>'+r.formal+'</td><td>'+r.cls+'</td><td>'+r.source+'</td><td>'+r.mw+' g/mol</td></tr>'; }
  let recRows=''; for(const id in RECIPES){ const rec=RECIPES[id]; recRows+='<tr><td>'+rec.label+'</td><td>'+id+'</td><td>'+Object.keys(rec.cost).map(k=>k+': '+rec.cost[k]).join(', ')+'</td></tr>'; }
  card.innerHTML = '<h3>ref</h3><div class="mini">分子量影響費洛蒙消散半衰期（≥60s於 1×）。</div>'+
    '<table><thead><tr><th>簡名</th><th>正式名</th><th>類別</th><th>來源腺體</th><th>MW</th></tr></thead><tbody>'+phRows+'</tbody></table>'+
    '<h4>配方</h4><table><thead><tr><th>費洛蒙</th><th>ID</th><th>材料</th></tr></thead><tbody>'+recRows+'</tbody></table>'+
    '<div style="text-align:right;margin-top:8px"><button onclick="closeRef()">關閉</button></div>';
  modal.style.display='grid';
}
function closeRef(){ document.getElementById('refModal').style.display='none'; } window.closeRef=closeRef;

/*********** View & inputs ***********/
function clampView(){ const rect=canvas.getBoundingClientRect(); const vw=rect.width/(window.devicePixelRatio||1)/viewScale; const vh=rect.height/(window.devicePixelRatio||1)/viewScale; viewX=Math.max(0, Math.min(WORLD_W - vw, viewX)); viewY=Math.max(0, Math.min(WORLD_H - vh, viewY)); }
document.getElementById('btnZoomIn').onclick=function(){ const rect=canvas.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; zoomAround(cx,cy,1.1); };
document.getElementById('btnZoomOut').onclick=function(){ const rect=canvas.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; zoomAround(cx,cy,0.9); };
document.getElementById('btnZoomReset').onclick=function(){ viewScale=1; clampView(); };
function zoomAround(cx,cy,factor){ const rect=canvas.getBoundingClientRect(); const dpr=window.devicePixelRatio||1; const mx=(cx-rect.left)/dpr; const my=(cy-rect.top)/dpr; const worldX = viewX + mx / viewScale; const worldY = viewY + my / viewScale; const newScale = Math.min(4, Math.max(0.5, viewScale*factor)); if(newScale===viewScale) return; viewX = worldX - (mx / newScale); viewY = worldY - (my / newScale); viewScale = newScale; clampView(); }
const panelClock=document.getElementById('clock'); const cclock=panelClock.getContext('2d');
let clockAngMin=0, clockAngHour=0;
function drawClock(dt){ // simulate hand speeds based on timeScale
  const speed = timeScale; // 1..100
  clockAngMin = (clockAngMin + dt*speed*2*Math.PI/5) % (2*Math.PI); // fast spin
  clockAngHour = (clockAngHour + dt*speed*2*Math.PI/40) % (2*Math.PI);
  const w=panelClock.width, h=panelClock.height; cclock.setTransform(1,0,0,1,0,0); cclock.clearRect(0,0,w,h);
  cclock.translate(w/2, h/2);
  cclock.fillStyle="#0c1020"; cclock.strokeStyle="#2b3246"; cclock.lineWidth=2; cclock.beginPath(); cclock.arc(0,0,56,0,Math.PI*2); cclock.fill(); cclock.stroke();
  cclock.strokeStyle="#9aa4b2";
  for(let i=0;i<12;i++){ const a=i*Math.PI/6; cclock.beginPath(); cclock.moveTo(Math.cos(a)*44, Math.sin(a)*44); cclock.lineTo(Math.cos(a)*52, Math.sin(a)*52); cclock.stroke(); }
  // hour hand
  cclock.strokeStyle="#77e4a0"; cclock.lineWidth=4; cclock.beginPath(); cclock.moveTo(0,0); cclock.lineTo(Math.cos(clockAngHour)*28, Math.sin(clockAngHour)*28); cclock.stroke();
  // minute hand
  cclock.strokeStyle="#ffd36e"; cclock.lineWidth=3; cclock.beginPath(); cclock.moveTo(0,0); cclock.lineTo(Math.cos(clockAngMin)*42, Math.sin(clockAngMin)*42); cclock.stroke();
}
document.getElementById('speedUp').onclick=function(){ timeScale=Math.min(100, timeScale+1); document.getElementById('speedLabel').textContent=timeScale.toFixed(0)+'×'; };
document.getElementById('speedDown').onclick=function(){ timeScale=Math.max(1, timeScale-1); document.getElementById('speedLabel').textContent=timeScale.toFixed(0)+'×'; };
document.getElementById('btnRestart').onclick=function(){ resetGame(); };
document.getElementById('levelSel').onchange=function(e){ level=parseInt(e.target.value,10); resetGame(); };
document.getElementById('btnRef').onclick=function(){ openRef(); };

/*********** Targets (Lv2) ***********/
function stepTargets(dt){
  for(let y=0;y<H;y++){ for(let x=0;x<W;x++){
    if(grid[idx(x,y)].type!==T_TARGET) continue;
    let me=0, rv=0;
    for(const a of ants){ if(Math.hypot(a.x-(x*TILE+TILE/2), a.y-(y*TILE+TILE/2))<18) me++; }
    for(const a of antsRival){ if(Math.hypot(a.x-(x*TILE+TILE/2), a.y-(y*TILE+TILE/2))<18) rv++; }
    const diff = me - rv;
    grid[idx(x,y)].control = clamp((grid[idx(x,y)].control||0) + diff*dt*0.5, -10, 10);
    if(grid[idx(x,y)].control>=10) grid[idx(x,y)].owner='me';
    else if(grid[idx(x,y)].control<=-10) grid[idx(x,y)].owner='rv';
  } } 
}

/*********** Next actions ***********/
let nextReady=false;
function showNextAction(label, btnText, showEnemyBtn){
  nextReady=true;
  const box=document.getElementById('nextActions'); box.style.display='flex';
  document.getElementById('nextLabel').textContent=label||'';
  const btn=document.getElementById('btnNext');
  if(btnText){ btn.style.display='inline-block'; btn.textContent=btnText; } else { btn.style.display='none'; }
  const be=document.getElementById('btnAddEnemy');
  if(showEnemyBtn){ be.style.display='inline-block'; be.onclick=function(){ enemies.push(makeEnemy(choice(['spider','gecko','roach']))); hideNextAction(); }; }
  else { be.style.display='none'; }
}
function hideNextAction(){ const box=document.getElementById('nextActions'); if(!box) return; box.style.display='none'; document.getElementById('btnNext').style.display='none'; document.getElementById('btnAddEnemy').style.display='none'; nextReady=false; }

/*********** Main loop ***********/
function resetGame(){
  ants=[]; antsRival=[]; inventory={}; mats={}; scoreMe=0; scoreRival=0; carrying=0; unlocked=Object.keys(RECIPES); selectedPh='m4mp2c'; MATERIALS.forEach(k=>mats[k]=0);
  targets=[]; enemies=[]; nextReady=false; hideNextAction();
  baseRandomMap(); if(level===1||level===3||level===4) placeNestsCorners(); else placeNestsRandom();
  if(level===1) scatterFood(['sugar','peanut','fish'], 22);
  if(level===2) { scatterFood(['resin','citrus','oil'], 18); spawnTargets(4); }
  if(level===3) { scatterFood(['berry','wax','chitin'], 18); enemies=[makeEnemy('spider'), makeEnemy('spider'), makeEnemy('gecko'), makeEnemy('roach')]; }
  if(level===4) scatterFood(['resin','citrus','oil'], 18);
  setGoal(level===1?'Lv1：搬回顆粒數量要超過對手。': level===2?'Lv2：限時佔領控制點。': level===3?'Lv3：敵人可被擊敗轉為食物。':'Lv4：吸引＋禁止導引示意。');
  showTimer = (level!==1); timeLeft = showTimer? (level===2?160:150) : 0; colonyCap = (level===1?30:level===2?60:80); colonyMax=(level===1?500:Infinity);
  for(let i=0;i<10;i++) ants.push(spawnAnt('me')); for(let i=0;i<50;i++) antsRival.push(spawnAnt('rv'));
  buildCraftSel(); refreshInv(); refreshMats(); resizeCanvas(); clampView(); draw(); updateHud();
}
let _last=performance.now();
function loop(now){ let dt=(now-_last)/1000; _last=now; // real seconds
  step(dt*timeScale); draw(); drawClock(dt); requestAnimationFrame(loop);
}
function step(dt){
  stepWeather(dt);
  if(showTimer){ timeLeft=Math.max(0,timeLeft-dt); const t=document.getElementById('timerText'); if(t) t.textContent=Math.ceil(timeLeft); }
  stepPher(dt);
  const want=desiredPopulation(); if(ants.length < want){ spawnBudget += dt * 10; while(spawnBudget>=1 && ants.length<want){ ants.push(spawnAnt('me')); spawnBudget-=1; } }
  if(antsRival.length < rivalSpawn){ if(Math.random()<0.4*dt) antsRival.push(spawnAnt('rv')); }
  for(const a of ants) stepAnt(a, dt);
  for(const a of antsRival) stepAnt(a, dt);
  if(level===2){ stepTargets(dt); }
  if(level>=3){ stepEnemies(dt); }
  updateHud();
}

/*********** Drawing ***********/
function groundColor(t){ if(t===T_WATER) return '#0a1830'; if(t===T_WALL) return '#0a0a10'; if(t===T_TARGET) return '#0c101a'; return '#0c101a'; }
function drawTarget(x,y){
  const cx=x*TILE+TILE/2, cy=y*TILE+TILE/2; const c=grid[idx(x,y)];
  ctx.lineWidth=2; let col='#999'; if(c.owner==='me') col='#77e4a0'; else if(c.owner==='rv') col='#cfd3da88';
  ctx.strokeStyle=col; ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.arc(cx,cy,10,0,Math.PI*2); ctx.stroke();
}
function drawEnemy(e){ if(!e.alive) return; ctx.save(); ctx.translate(e.x, e.y); const s=e.scale;
  if(e.kind==='spider'){ ctx.strokeStyle='#ff8bd1'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,6*s,0,Math.PI*2); ctx.stroke(); for(let i=0;i<4;i++){ const a=i*Math.PI/4 + Math.PI/8; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(a)*10*s, Math.sin(a)*10*s); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-Math.cos(a)*10*s, -Math.sin(a)*10*s); ctx.stroke(); } }
  else if(e.kind==='gecko'){ ctx.strokeStyle='#a7ff8a'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,0,8*s,4*s,0,0,Math.PI*2); ctx.stroke(); }
  else { ctx.strokeStyle='#ffd36e'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,0,7*s,3*s,0,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-6*s,0); ctx.lineTo(6*s,0); ctx.stroke(); }
  ctx.restore(); }
function draw(){
  const dpr=window.devicePixelRatio||1; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.scale(dpr,dpr); ctx.save(); ctx.scale(viewScale,viewScale); ctx.translate(-viewX,-viewY);
  ctx.fillStyle=groundColor(T_EMPTY); ctx.fillRect(0,0,WORLD_W,WORLD_H);
  for(let y=0;y<H;y++){ for(let x=0;x<W;x++){
    const c=grid[idx(x,y)]; const col=groundColor(c.type); ctx.fillStyle=col; ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
    if(c.type===T_TARGET){ drawTarget(x,y); }
    // pheromones
    for(const k in c.pherMe){ ctx.fillStyle=PH[k].color; ctx.globalAlpha=Math.min(0.5,c.pherMe[k]); ctx.fillRect(x*TILE,y*TILE,TILE,TILE); ctx.globalAlpha=1; }
    for(const k in c.pherRv){ ctx.fillStyle="#cfd3da44"; ctx.globalAlpha=Math.min(0.5,c.pherRv[k]); ctx.fillRect(x*TILE,y*TILE,TILE,TILE); ctx.globalAlpha=1; }
    if(c.type===T_FOOD){ drawFood(x,y,c.food); }
  } }
  // nests
  for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ const t=grid[idx(x,y)].type; if(t===T_NEST_ME){ ctx.fillStyle='#77e4a0'; ctx.fillRect(x*TILE+2,y*TILE+2,TILE-4,TILE-4);} else if(t===T_NEST_RIVAL){ ctx.fillStyle='#cfd3da44'; ctx.fillRect(x*TILE+2,y*TILE+2,TILE-4,TILE-4);} } }
  // ants
  function drawAnt(a, sprites){ const phase=(Math.floor((performance.now()/120 + a.x*0.01)%2))?1:0; const sidx=(Math.cos(a.aim)>=0?0:2)+phase; const off=sprites[sidx]; ctx.drawImage(off, a.x-ANT_W/2, a.y-ANT_H/2, ANT_W, ANT_H); }
  for(const a of ants) drawAnt(a, frames.antsMe); for(const a of antsRival) drawAnt(a, frames.antsRv);
  enemies.forEach(drawEnemy);
  ctx.restore();
}

/*********** Boot ***********/
(function(){ try{ resizeCanvas(); level=1; resetGame(); requestAnimationFrame(loop); } catch(err){ const box=document.getElementById('errorOverlay'); const pre=document.getElementById('errorText'); box.style.display='block'; pre.textContent=String(err && err.stack || err); console.error(err); } })();
</script>
</body>
</html>
