<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>模式螞蟻費洛蒙策略遊戲 v0.7.4.1</title>
<style>
  :root { --bg:#0f1115; --panel:#151922; --ink:#e8eefc; --muted:#9aa4b2; --accent:#77e4a0; --danger:#ff7a7a; --warn:#ffd36e; --hi:#ffffff; }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, PingFangTC, "Noto Sans TC", Segoe UI, Roboto, Helvetica, Arial;}
  #wrap{display:grid; grid-template-columns: 1fr 320px; gap:8px; height:100vh; padding:8px; box-sizing:border-box;}
  #stage{position:relative; width:100%; height:100%; overflow:hidden}
  #canvas{position:absolute; inset:0; background:#0b0d12; border:1px solid #22283a; border-radius:12px; width:100%; height:100%; display:block; image-rendering:pixelated; cursor:crosshair}
  #panel{background:var(--panel); border-radius:12px; padding:8px; overflow:auto; display:grid; gap:8px}
  .slot{background:#101625; border:1px solid #2b3246; border-radius:10px; padding:8px; display:flex; align-items:center; gap:8px; justify-content:space-between}
  .col{display:flex; flex-direction:column; gap:8px; width:100%}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .between{justify-content:space-between}
  button,select,input[type=range]{background:#23293a; color:var(--ink); border:1px solid #2b3246; border-radius:10px; padding:6px 10px; cursor:pointer}
  input[type=range]{-webkit-appearance: none; width:240px; height:8px; padding:0}
  input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; width:14px; height:14px; background:#77e4a0; border-radius:50% }
  button:hover{filter:brightness(1.08)}
  .mini{font-size:12px; color:var(--muted)}
  .label{font-size:12px; color:#cbd3e3; text-align:center}
  table{border-collapse:collapse; font-size:13px}
  th,td{border-bottom:1px solid #2b3246; padding:4px 6px; text-align:left; vertical-align:top}
  #dash4{display:grid; grid-template-columns: repeat(4, 1fr); gap:0; width:100%}
  .card{background:#0e1424; border:1px solid #2b3246; border-radius:10px; padding:4px; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px}
  .stack{display:flex; flex-direction:column; gap:4px; align-items:center; justify-content:center}
  canvas.mini{background:#0c1020; border:1px solid #2b3246; border-radius:10px}
  #errorOverlay{position:fixed; right:12px; bottom:12px; display:none; z-index:9999; background:#1d2233; color:#ffd1d1; border:1px solid #b44; border-radius:12px; padding:12px; box-shadow:0 6px 30px #0008; max-width:46vw}
  #errorOverlay pre{white-space:pre-wrap; font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; color:#ffd1d1}
  #refModal{position:fixed; inset:0; display:none; place-items:center; background:#0008; z-index:9998}
  #refCard{width:min(1040px,94vw); height:min(86vh,820px); background:#111522; border:1px solid #2b3246; border-radius:14px; overflow:auto; padding:16px}
  #refClose{position:sticky; top:0; display:inline-block; margin-left:auto; background:#23293a}
  code.k{background:#0c1020; padding:0 6px; border-radius:6px; border:1px solid #2b3246}
  #top2{display:grid; grid-template-columns: 1fr 1fr; gap:6px}
  .mat{padding:2px 6px; border-radius:6px; border:2px solid #2b3246; background:#0c1020}
  .mat.hi{font-weight:800; color:#ffffff}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, monospace}
  @media (orientation:portrait){
    #wrap{grid-template-columns: 1fr; grid-template-rows: 1fr auto}
    #panel{order:2}
    #stage{order:1; height:60vh}
    #dash4{order:99}
  }
</style>
</head>
<body>
  <div id="wrap">
    <div id="stage"><canvas id="canvas"></canvas></div>
    <div id="panel">
      <div id="top2">
        <div class="slot" style="gap:6px; width:100%">
          <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:6px; width:100%">
            <div class="col" style="align-items:center">
              <div><b>關卡</b></div>
              <select id="levelSel"><option value="1">Lv1</option><option value="2">Lv2</option><option value="3">Lv3</option><option value="4">Lv4</option></select>
            </div>
            <button id="btnRestart">reset</button>
            <button id="btnRef">ref</button>
          </div>
        </div>
        <div class="slot">
          <table style="width:auto"><thead><tr><th></th><th>螞蟻</th><th>分</th></tr></thead>
            <tbody>
              <tr><td>我</td><td id="meAnts">0</td><td id="meScore">0</td></tr>
              <tr><td>敵</td><td id="rvAnts">0</td><td id="rvScore">0</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="col">
        <div id="dash4">
          <div class="card stack"><div class="label">風速</div><canvas id="wxClock" class="mini" width="60" height="60"></canvas></div>
          <div class="card stack"><div class="label">溼度</div><canvas id="humGauge" class="mini" width="60" height="60"></canvas></div>
          <div class="card stack"><div class="label">時間</div><canvas id="spdClock" class="mini" width="60" height="60"></canvas></div>
          <div class="card stack"><div class="label">視窗</div><canvas id="zoomGauge" class="mini" width="60" height="60"></canvas></div>
        </div>
        <div class="row" style="justify-content:center">
          <span class="mini">1×</span>
          <input id="speedSlider" type="range" min="1" max="100" value="1">
          <span class="mini">100×</span>
        </div>
        <div class="mini" style="text-align:center">累積時間：<span id="accumTime" class="mono">00:00:00:00</span></div>
      </div>

      <div class="slot" style="display:grid; grid-template-columns: 1fr 1fr; gap:8px">
        <div class="col">
          <b>材料</b>
          <div id="matRow" class="row"></div>
          <div class="mini">蛋白質（我）<span id="proteinMe">0</span>／（敵）<span id="proteinRv">0</span></div>
          <div class="row between">
            <span class="row"><b>費洛蒙</b> <select id="craftSel"></select></span>
            <button id="btnCraft">合成 +1</button>
          </div>
        </div>
        <div class="col">
          <b>食物碎塊</b>
          <div class="row between">
            <div class="mini">目前數量：<span id="fragCount">—</span></div>
            <button id="btnMoreFood" style="display:none">灑食物</button>
          </div>
          <b>庫存</b>
          <div id="invList" class="row"></div>
        </div>
      </div>

      <div id="refModal"><div id="refCard">
        <div class="row" style="justify-content:flex-end"><button id="refClose">關閉</button></div>
        <h2>參考（ref）</h2>
        <p class="mini">費洛蒙功能表、合成配方、各種食物材料含量。</p>
        <h3>費洛蒙功能表</h3>
        <table id="refPhTable"><thead><tr><th>遊戲名</th><th>正式/學名</th><th>類型</th><th>分子量估</th><th>顏色</th><th>說明</th></tr></thead><tbody></tbody></table>
        <h3>費洛蒙合成配方</h3>
        <table id="refRecipeTable"><thead><tr><th>遊戲名</th><th>配方（材料→數量）</th></tr></thead><tbody></tbody></table>
        <h3>各種食物的材料含量（基礎 1×）</h3>
        <table id="refFoodTable"><thead><tr><th>食物</th><th>外觀</th><th>基礎材料</th></tr></thead><tbody></tbody></table>
      </div></div>

    </div>
  </div>

  <div id="errorOverlay"><b>⚠️ 腳本錯誤</b><pre id="errorText"></pre></div>

<script>
'use strict';
function reportError(err){ try{ const box=document.getElementById('errorOverlay'); const pre=document.getElementById('errorText'); box.style.display='block'; pre.textContent=String(err && err.stack || err); console.error(err);}catch(_){ } }
const PI=Math.PI; function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; } function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function rr(o,x,y,w,h,r){ if(o.roundRect){ o.beginPath(); o.roundRect(x,y,w,h,r); o.fill(); o.stroke(); return; } r=Math.min(r,w/2,h/2); o.beginPath(); o.moveTo(x+r,y); o.arcTo(x+w,y,x+w,y+h,r); o.arcTo(x+w,y+h,x,y+h,r); o.arcTo(x,y+h,x,y,r); o.arcTo(x,y,x+w,y,r); o.closePath(); o.fill(); o.stroke(); }
function clone(obj){ try{ return JSON.parse(JSON.stringify(obj)); }catch(_){ return null; }}

const REF=[
  {id:'m4mp2c',label:'吡咯酸甲酯',cls:'trail',mw:169,color:'#9bf',note:'路徑/食物跟隨'},
  {id:'edp',label:'乙基二甲基吡嗪',cls:'trail',mw:136,color:'#8cf',note:'路徑/食物跟隨'},
  {id:'faranal',label:'Faranal',cls:'trail',mw:208,color:'#6fa',note:'路徑/遠距跟隨'},
  {id:'mono1',label:'Monomorine I',cls:'recruit',mw:195,color:'#dff76a',note:'招募/集結'},
  {id:'noentry',label:'禁止混合物',cls:'ban',mw:160,color:'#f77',note:'避免重複前往'},
  {id:'formic',label:'蟻酸',cls:'acid',mw:46,color:'#f55',note:'攻擊/警戒'}
];
const MATERIALS=['C','O','N','R','T','Ald','Acid','HC','LAC'];
const RECIPES={m4mp2c:{label:'吡咯酸甲酯',cost:{C:1,O:1,N:1}}, edp:{label:'乙基二甲基吡嗪',cost:{N:2,R:1,C:1}}, faranal:{label:'Faranal',cost:{T:2,Ald:1,HC:1}}, mono1:{label:'Monomorine I',cost:{N:1,R:1,HC:1}}, noentry:{label:'禁止混合物',cost:{Ald:1,Acid:1,HC:1}}, formic:{label:'蟻酸',cost:{Acid:2}}};
const PH={}; for(const r of REF){ PH[r.id]={type:r.cls,color:r.color,halfLife:3600,label:r.label,note:r.note,mw:r.mw}; } // 1h 半衰期

const FOOD_BASE={
  fish:   {label:'魚',     base:{N:2,C:1},    art:'fish'},
  peanut: {label:'堅果',   base:{C:2,R:1},    art:'nut'},
  cater:  {label:'毛毛蟲', base:{N:2,HC:1},   art:'cater'},
  resin:  {label:'樹脂',   base:{T:2,C:1},    art:'resin'},
  citrus: {label:'柑橘',   base:{Ald:1,O:1,R:1}, art:'citrus'},
  oil:    {label:'油脂',   base:{HC:2,C:1},   art:'oil'},
  berry:  {label:'漿果',   base:{Acid:2,O:1}, art:'berry'},
  wax:    {label:'蜂蠟',   base:{HC:2},       art:'wax'},
  chitin: {label:'甲殼',   base:{N:1,Acid:1,R:1}, art:'chitin'}
};

const TILE=16; let W=64, H=48; const WORLD_W=W*TILE, WORLD_H=H*TILE;
const T_EMPTY=0, T_WATER=1, T_FOOD=2, T_NEST_ME=3, T_NEST_RIVAL=4;
let level=1, timeScale=1.0, maxAnts=500;
const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d');
function resizeCanvas(){ const rect=canvas.getBoundingClientRect(); const dpr=window.devicePixelRatio||1; canvas.width=Math.max(1, Math.floor(rect.width*dpr)); canvas.height=Math.max(1, Math.floor(rect.height*dpr)); }
window.addEventListener('resize', resizeCanvas); resizeCanvas();
function inBounds(x,y){ return x>=0&&y>=0&&x<W&&y<H; } function idx(x,y){ return y*W+x; }

let grid=[], ants=[], antsRival=[], scoreMe=0, scoreRival=0, mats={}, inventory={}, selectedPh='m4mp2c';
let proteinMe=0, proteinRv=0;
let viewScale=1.0, viewX=0, viewY=0;
let wx={wind:1.2, windDir:0, humidIdx:3, raining:false, tDir:0};

// time model
let hasAccelerated=false;
let simElapsed = 0;          // 累積的模擬秒數（含快轉）
let baseTaipei = null;       // 遊戲開始的台北時間

function taipeiNowDate(){
  const fmt = new Intl.DateTimeFormat('zh-TW',{timeZone:'Asia/Taipei', hour12:false, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit'});
  const parts = fmt.formatToParts(new Date());
  const get = t => Number(parts.find(p=>p.type==t).value);
  return new Date(get('year'), get('month')-1, get('day'), get('hour'), get('minute'), get('second'));
}

let initialFoodCount = 22;

let isPanning=false, panStart={x:0,y:0}, viewStart={x:0,y:0};
canvas.addEventListener('mousedown', e=>{ if(e.button!==1) { isPanning=true; } panStart={x:e.clientX,y:e.clientY}; viewStart={x:viewX,y:viewY}; });
window.addEventListener('mouseup', ()=>{ isPanning=false; });
window.addEventListener('mousemove', e=>{ if(!isPanning) return; const dpr=window.devicePixelRatio||1; const dx=(e.clientX-panStart.x)/dpr/viewScale; const dy=(e.clientY-panStart.y)/dpr/viewScale; viewX = clamp(viewStart.x - dx, 0, WORLD_W-canvas.width/(dpr*viewScale)); viewY = clamp(viewStart.y - dy, 0, WORLD_H-canvas.height/(dpr*viewScale)); });
canvas.addEventListener('wheel', e=>{ e.preventDefault(); const rect=canvas.getBoundingClientRect(); const dpr=window.devicePixelRatio||1; const mx=(e.clientX-rect.left)/dpr; const my=(e.clientY-rect.top)/dpr; const wxp=mx/viewScale + viewX; const wyp=my/viewScale + viewY; const s = Math.exp(-e.deltaY*0.001); const ns = clamp(viewScale*s, 0.5, 4); viewScale=ns; viewX=clamp(wxp - mx/viewScale,0,Math.max(0,WORLD_W-canvas.width/(dpr*viewScale))); viewY=clamp(wyp - my/viewScale,0,Math.max(0,WORLD_H-canvas.height/(dpr*viewScale))); }, {passive:false});

function baseRandomMap(){
  grid=new Array(W*H).fill(0).map(()=>({type:T_EMPTY, pherMe:{}, pherRv:{}, food:null}));
  const pools = randInt(2,4);
  for(let i=0;i<pools;i++){
    const cx=randInt(6, W-7), cy=randInt(6, H-7), r = randInt(4,8);
    for(let y=cy-r-1; y<=cy+r+1; y++){ for(let x=cx-r-1; x<=cx+r+1; x++){
      if(!inBounds(x,y)) continue; const dx=x-cx, dy=y-cy; const d=Math.sqrt(dx*dx+dy*dy) + (Math.random()*0.8-0.4); if(d<r) grid[idx(x,y)].type=T_WATER;
    }}}
  grid[idx(2,2)].type=T_NEST_ME; grid[idx(W-3,H-3)].type=T_NEST_RIVAL;
}
function scaleYield(base, size){ const out={}; for(const k in base){ out[k]=Math.max(1, Math.round(base[k]*size)); } return out; }
function makeFood(kind, size){
  const spec=FOOD_BASE[kind]||FOOD_BASE.peanut; const frags=[]; const n=Math.max(3, Math.round(3+size));
  for(let i=0;i<n;i++){ const r = (Math.random()*3 + 1.5) * (0.7 + 0.3*size); const ox=(Math.random()*0.6-0.3)*(TILE-6)*size*0.4, oy=(Math.random()*0.6-0.3)*(TILE-6)*size*0.4; frags.push({ox,oy,r}); }
  return {type:kind, label:spec.label, art:spec.art, size, frags, yield:scaleYield(spec.base,size)};
}
function scatterFood(list,count){ for(let i=0;i<count;i++){ const x=randInt(2,W-3), y=randInt(2,H-3); if(grid[idx(x,y)].type===T_EMPTY){ const kind=choice(list); const size=randInt(1,5); grid[idx(x,y)].type=T_FOOD; grid[idx(x,y)].food=makeFood(kind,size); } else i--; } }

function stepWeather(dt){
  const mean=1.2, k=0.9;
  wx.wind = clamp(wx.wind + (mean - wx.wind)*k*dt + (Math.random()-0.5)*0.6*dt, 0, 4.0);
  wx.tDir = (wx.tDir||0) + dt; if(wx.tDir>=30){ wx.windDir = (wx.windDir + (Math.random()*300 - 150)) % 360; wx.tDir=0; }
  if(Math.random()<0.02*dt){ wx.humidIdx = clamp(wx.humidIdx + (Math.random()<0.5?-1:1), 0, 9); }
  wx.raining = (wx.humidIdx>=9 && wx.wind>3.2);
}

function ensureEntry(bucket, key){ return bucket[key]||(bucket[key]={s:0,vx:0,vy:0}); }
function placePher(gx,gy,key,amt,team,vx,vy){
  if(!inBounds(gx,gy)) return; const c=grid[idx(gx,gy)]; if(c.type===T_WATER) return;
  const bucket = (team==='rv')? c.pherRv : c.pherMe; const e = ensureEntry(bucket, key);
  e.s += amt; e.vx += (vx||0)*amt; e.vy += (vy||0)*amt;
}
function stepPher(dt){
  const windRad = wx.windDir*Math.PI/180; const wxvx=Math.cos(windRad), wxvy=Math.sin(windRad);
  const diffBase = 0.06 * dt; const advBase = 0.05 * dt * (wx.wind/4);
  const rainWash = wx.raining ? Math.exp(-dt*0.6) : 1;
  const addMe = new Array(W*H), addRv = new Array(W*H);
  for(let i=0;i<grid.length;i++){ addMe[i]={}; addRv[i]={}; }
  function processBucket(src, add){
    for(let y=0;y<H;y++){ for(let x=0;x<W;x++){
      const cell=grid[idx(x,y)]; const p=(src==='me')?cell.pherMe:cell.pherRv;
      for(const key in p){
        const ph=p[key]; let s=ph.s; if(s<=0) continue;
        const half = 3600; // 固定 1h 半衰期
        const lambda=Math.LN2/half;
        s = s*Math.exp(-lambda*dt) * rainWash; if(s<0.01) continue;
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; let remain=s;
        for(const d of dirs){
          const nx=x+d[0], ny=y+d[1]; if(!inBounds(nx,ny)) continue; if(grid[idx(nx,ny)].type===T_WATER) continue;
          const len=Math.hypot(d[0],d[1])||1, dxn=d[0]/len, dyn=d[1]/len;
          const windAlign = Math.max(-1, Math.min(1, dxn*wxvx + dyn*wxvy));
          const bias = 1 + 0.6*windAlign*(wx.wind/4);
          const flow = Math.min(remain*0.5, diffBase * s * bias);
          if(flow>0){
            remain -= flow;
            const acc = add[idx(nx,ny)][key] || (add[idx(nx,ny)][key]={s:0,vx:0,vy:0});
            acc.s += flow; acc.vx += ph.vx*(flow/s) + dxn*flow*0.15 + wxvx*flow*advBase; acc.vy += ph.vy*(flow/s) + dyn*flow*0.15 + wxvy*flow*advBase;
          }
        }
        const here = add[idx(x,y)][key] || (add[idx(x,y)][key]={s:0,vx:0,vy:0});
        here.s += remain; const denom=Math.max(1e-6, ph.s); here.vx += ph.vx*(remain/denom); here.vy += ph.vy*(remain/denom);
      }
    }}
  }
  processBucket('me', addMe); processBucket('rv', addRv);
  for(let i=0;i<grid.length;i++){ grid[i].pherMe=addMe[i]; grid[i].pherRv=addRv[i]; }
}

function senseVector(gx,gy,team){
  if(!inBounds(gx,gy)) return {vx:0,vy:0,mag:0};
  const bucket = (team==='rv')? grid[idx(gx,gy)].pherRv : grid[idx(gx,gy)].pherMe;
  let vx=0, vy=0, mag=0;
  for(const key in bucket){
    const e=bucket[key]; const type=(PH[key]&&PH[key].type)||'trail';
    const sign = (type==='trail'||type==='recruit')? +1 : -1;
    vx += sign * e.vx; vy += sign * e.vy; mag += e.s;
  }
  return {vx,vy,mag:mag};
}
function nearestObjectVector(gx,gy){
  let bestD2=1e9, bestDX=0, bestDY=0;
  for(let y=gy-2; y<=gy+2; y++){ for(let x=gx-2; x<=gx+2; x++){
    if(!inBounds(x,y)) continue; const c=grid[idx(x,y)];
    if(c.type===T_FOOD || c.type===T_NEST_ME || c.type===T_NEST_RIVAL){
      const dx=x-gx, dy=y-gy; const d2=dx*dx+dy*dy; if(d2<bestD2){ bestD2=d2; bestDX=dx; bestDY=dy; }
    } else {
      let s=0; for(const k in c.pherMe){ s += (c.pherMe[k] && c.pherMe[k].s)||0; } for(const k in c.pherRv){ s += (c.pherRv[k] && c.pherRv[k].s)||0; }
      if(s>0.6){ const dx=x-gx, dy=y-gy; const d2=dx*dx+dy*dy; if(d2<bestD2){ bestD2=d2; bestDX=dx; bestDY=dy; } }
    }
  }}
  if(bestD2>(1.5*1.5)) return {vx:0,vy:0,mag:0};
  const len=Math.sqrt(bestD2)||1e-6; return {vx:bestDX/len, vy:bestDY/len, mag:1/len};
}

function findNest(team){ for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ const t=grid[idx(x,y)].type; if(team==='me'&&t===T_NEST_ME) return {x,y}; if(team==='rv'&&t===T_NEST_RIVAL) return {x,y}; } } return {x:1,y:1}; }
function spawnAnt(team){
  const n=findNest(team); const px=n.x*TILE+TILE/2, py=n.y*TILE+TILE/2; 
  const sector = Math.floor(Math.random()*8); const baseAng = sector*(PI/4) + (Math.random()-0.5)*(PI/12);
  return {team, x:px, y:py, aim:baseAng, speed:26+Math.random()*10, carry:false, state:'foraging', load:null, hp:3, phCharge:4, phMax:6, dropCooldown:0, since:0, stuckT:0, stuckOriginX:px, stuckOriginY:py, inWater:false, speedFactor:1, age:0};
}
function stepAnt(a, dt){
  a.age += dt; a.since += dt*a.speed;
  const gx=Math.floor(a.x/TILE), gy=Math.floor(a.y/TILE);
  const vec = senseVector(gx,gy,a.team);
  const near = nearestObjectVector(gx,gy);
  let biasVX=0, biasVY=0;
  if(a.state==='foraging' && a.age<6 && vec.mag<0.1){
    const nest=findNest(a.team); const vx=(a.x-(nest.x*TILE+TILE/2)), vy=(a.y-(nest.y*TILE+TILE/2)); const len=Math.hypot(vx,vy)||1; biasVX=vx/len; biasVY=vy/len;
  }
  const nest=findNest(a.team);
  let steerVX, steerVY;
  if(a.state==='carrying'){
    const dirToNest = Math.atan2(nest.y*TILE+TILE/2 - a.y, nest.x*TILE+TILE/2 - a.x);
    const toVX = Math.cos(dirToNest), toVY = Math.sin(dirToNest);
    steerVX = toVX*1.6 + 0.2*vec.vx;
    steerVY = toVY*1.6 + 0.2*vec.vy;
  } else {
    steerVX = vec.vx + 0.8*near.vx + 0.6*biasVX;
    steerVY = vec.vy + 0.8*near.vy + 0.6*biasVY;
  }
  const steerMag = Math.hypot(steerVX,steerVY);
  if(steerMag>0.02){ const dir = Math.atan2(steerVY, steerVX); const turn = ((dir - a.aim + PI*3)%(PI*2))-PI; a.aim += clamp(turn, -0.25, 0.25) * 0.65; a.since = 0; }
  else if(a.since > (a.state==='carrying'? 12 : 4)){ a.since = 0; if(a.state!=='carrying') a.aim += (Math.random()-0.5)*PI; }
  if(a.state==='carrying'){ if(a.dropCooldown<=0 && a.phCharge>0){ const dirToNest=Math.atan2(nest.y*TILE+TILE/2 - a.y, nest.x*TILE+TILE/2 - a.x); placePher(gx,gy,'m4mp2c', 0.7, a.team, Math.cos(dirToNest), Math.sin(dirToNest)); a.phCharge--; a.dropCooldown=0.2; } else a.dropCooldown=Math.max(0,a.dropCooldown-dt); }
  let sp=a.speed*dt*a.speedFactor; let nx=a.x+Math.cos(a.aim)*sp, ny=a.y+Math.sin(a.aim)*sp; let cgx=Math.floor(nx/TILE), cgy=Math.floor(ny/TILE);
  if(!inBounds(cgx,cgy) || grid[idx(cgx,cgy)].type===T_WATER){ a.aim += (Math.random()-0.5)*PI; } else { a.x=nx; a.y=ny; }
  const dx=a.x - a.stuckOriginX, dy=a.y - a.stuckOriginY; const nearRadius = 0.75*TILE;
  if(dx*dx+dy*dy > nearRadius*nearRadius){ a.stuckOriginX=a.x; a.stuckOriginY=a.y; a.stuckT=0; }
  else { a.stuckT += dt; if(a.stuckT>=60 && !a.inWater){ let best=null, bestD2=1e12; for(let y=gy-6;y<=gy+6;y++){ for(let x=gx-6;x<=gx+6;x++){ if(!inBounds(x,y)) continue; if(grid[idx(x,y)].type!==T_WATER) continue; const wxp=x*TILE+TILE/2, wyp=y*TILE+TILE/2; const dd=(wxp-a.x)**2+(wyp-a.y)**2; if(dd<bestD2){ bestD2=dd; best={x:wxp,y:wyp}; } }} if(best){ a.x=best.x; a.y=best.y; } a.inWater=true; a.speedFactor=0.1; } }
  const cg=grid[idx(Math.floor(a.x/TILE), Math.floor(a.y/TILE))];
  if(a.inWater){ if(cg.type!==T_WATER){ let nearD2=1e12; for(let y=gy-6;y<=gy+6;y++){ for(let x=gx-6;x<=gx+6;x++){ if(!inBounds(x,y)) continue; if(grid[idx(x,y)].type!==T_WATER) continue; const wxp=x*TILE+TILE/2, wyp=y*TILE+TILE/2; const dd=(wxp-a.x)**2+(wyp-a.y)**2; if(dd<nearD2) nearD2=dd; }} if(Math.sqrt(nearD2) > 2*TILE){ a.inWater=false; a.speedFactor=1.0; a.stuckT=0; a.stuckOriginX=a.x; a.stuckOriginY=a.y; } } }
  const cell=grid[idx(Math.floor(a.x/TILE), Math.floor(a.y/TILE))];
  if(a.state==='foraging' && cell.type===T_FOOD && cell.food && Array.isArray(cell.food.frags) && cell.food.frags.length){
    a.state='carrying'; a.carry=true; a.load=clone(cell.food.yield);
    placePher(gx,gy,'m4mp2c', 0.9, a.team, 0, 0);
    cell.food.frags.sort((u,v)=>u.r-v.r); cell.food.frags.shift();
    if(!cell.food.frags.length){ cell.type=T_EMPTY; cell.food=null; placePher(gx,gy,'noentry', 1.2, a.team, 0,0); }
  }
  const nestGX = nest.x, nestGY = nest.y;
  if(a.state==='carrying' && Math.floor(a.x/TILE)===nestGX && Math.floor(a.y/TILE)===nestGY){
    a.state='foraging'; a.carry=false;
    if(a.team==='me'){ 
      scoreMe++; 
      if(a.load){ for(const k in a.load){ mats[k]=(mats[k]||0)+(a.load[k]||0); } proteinMe += (a.load.N||0); }
      refreshMats(); refreshInv();
    } else {
      scoreRival++; if(a.load){ proteinRv += (a.load.N||0); }
    }
    a.load=null; a.phCharge=a.phMax;
  }
}

function autoRecruit(){
  const desiredMe = Math.min(maxAnts, 10 + proteinMe);
  while(ants.length < desiredMe){ ants.push(spawnAnt('me')); }
  const desiredRv = Math.min(maxAnts, 10 + proteinRv);
  while(antsRival.length < desiredRv){ antsRival.push(spawnAnt('rv')); }
}

function groundColor(t){ if(t===T_WATER) return '#0a1830'; return '#0c101a'; }
function drawFoodArt(cx,cy,size,art){
  const s=size*2.2; const o=ctx; o.save(); o.translate(cx,cy);
  if(art==='fish'){ o.fillStyle='#88b7ff'; o.strokeStyle='#ffffff66'; o.lineWidth=1; o.beginPath(); o.ellipse(0,0,4*s,2*s,0,0,2*PI); o.fill(); o.stroke(); o.beginPath(); o.moveTo(4*s,0); o.lineTo(6*s,1.5*s); o.lineTo(6*s,-1.5*s); o.closePath(); o.fill(); o.stroke(); o.beginPath(); o.ellipse(-1.5*s,-1.2*s,1.2*s,0.6*s,0.6,0,2*PI); o.fill(); o.stroke(); }
  else if(art==='nut'){ o.fillStyle='#caa86d'; o.strokeStyle='#ffffff55'; o.lineWidth=1; o.beginPath(); o.ellipse(0,0,3.2*s,2.6*s,0,0,2*PI); o.fill(); o.stroke(); o.beginPath(); o.moveTo(-2.2*s,0); o.quadraticCurveTo(0,-1.8*s,2.2*s,0); o.quadraticCurveTo(0,1.8*s,-2.2*s,0); o.stroke(); }
  else if(art==='cater'){ o.fillStyle='#77e4a0'; o.strokeStyle='#ffffff55'; o.lineWidth=1; for(let i=-3;i<=3;i++){ o.beginPath(); o.ellipse(i*1.6*s,0,1.4*s,1.1*s,0,0,2*PI); o.fill(); o.stroke(); } o.fillStyle='#e8eefcaa'; o.beginPath(); o.arc(3.2*s,-0.6*s,0.5*s,0,2*PI); o.fill(); }
  else if(art==='resin'){ o.fillStyle='#f6c84a'; o.strokeStyle='#ffffff55'; o.lineWidth=1; o.beginPath(); o.ellipse(0,0,2.8*s,2.2*s,0.3,0,2*PI); o.fill(); o.stroke(); }
  else if(art==='citrus'){ o.fillStyle='#ffa94d'; o.strokeStyle='#ffffff55'; o.beginPath(); o.ellipse(0,0,3*s,3*s,0,0,2*PI); o.fill(); o.stroke(); o.strokeStyle='#ffffff22'; for(let i=0;i<6;i++){ o.beginPath(); o.moveTo(0,0); const a=i*PI/3; o.lineTo(Math.cos(a)*3*s, Math.sin(a)*3*s); o.stroke(); } }
  else if(art==='oil'){ o.fillStyle='#c7ffd1'; o.strokeStyle='#ffffff55'; o.beginPath(); o.ellipse(0,0,3*s,2.2*s,0.4,0,2*PI); o.fill(); o.stroke(); }
  else if(art==='berry'){ o.fillStyle='#ff7aa8'; o.strokeStyle='#ffffff55'; o.beginPath(); o.ellipse(0,0,2.6*s,2.6*s,0,0,2*PI); o.fill(); o.stroke(); }
  else if(art==='wax'){ o.fillStyle='#ffd36e'; o.strokeStyle='#ffffff55'; o.beginPath(); o.rect(-2.6*s,-2.2*s,5.2*s,4.4*s); o.fill(); o.stroke(); }
  else if(art==='chitin'){ o.fillStyle='#b9d4ff'; o.strokeStyle='#ffffff55'; o.beginPath(); o.ellipse(0,0,3*s,2.2*s,0.2,0,2*PI); o.fill(); o.stroke(); }
  else { o.fillStyle='#ddd'; o.beginPath(); o.ellipse(0,0,2.6*s,2.2*s,0,0,2*PI); o.fill(); }
  o.restore();
}
function drawFood(x,y,food){
  const cx=x*TILE+TILE/2, cy=y*TILE+TILE/2;
  for(const f of food.frags){
    ctx.save(); ctx.translate(cx+f.ox, cy+f.oy); ctx.globalAlpha=0.96;
    drawFoodArt(0,0, Math.max(0.6, f.r/4), food.art);
    ctx.restore();
  }
}
function draw(){
  const dpr=window.devicePixelRatio||1; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.scale(dpr,dpr); ctx.save(); ctx.scale(viewScale,viewScale); ctx.translate(-viewX,-viewY);
  ctx.fillStyle=groundColor(0); ctx.fillRect(0,0,WORLD_W,WORLD_H);
  for(let y=0;y<H;y++){ for(let x=0;x<W;x++){
    const c=grid[idx(x,y)]; if(c.type===T_WATER){ ctx.fillStyle=groundColor(T_WATER); ctx.fillRect(x*TILE,y*TILE,TILE,TILE); }
    for(const key in c.pherMe){ const e=c.pherMe[key]; const a=Math.min(0.5, e.s*0.6); if(a>0.01){ ctx.globalAlpha=a; ctx.fillStyle=PH[key]?PH[key].color:'#68a0ff'; ctx.fillRect(x*TILE,y*TILE,TILE,TILE); ctx.globalAlpha=1; } }
    for(const key in c.pherRv){ const e=c.pherRv[key]; const a=Math.min(0.35, e.s*0.6); if(a>0.01){ ctx.globalAlpha=a; ctx.fillStyle="#cfd3da44"; ctx.fillRect(x*TILE,y*TILE,TILE,TILE); ctx.globalAlpha=1; } }
    if(c.type===T_FOOD) drawFood(x,y,c.food);
  } }
  for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ const t=grid[idx(x,y)].type; if(t===T_NEST_ME){ ctx.fillStyle='#77e4a0'; rr(ctx,x*TILE+2,y*TILE+2,TILE-4,TILE-4,4); } else if(t===T_NEST_RIVAL){ ctx.fillStyle='#cfd3da66'; rr(ctx,x*TILE+2,y*TILE+2,TILE-4,TILE-4,4);} } }
  ctx.fillStyle='#9ffcac'; for(const a of ants){ ctx.beginPath(); ctx.arc(a.x,a.y,2,0,2*PI); ctx.fill(); }
  ctx.fillStyle='#cfd3da88'; for(const a of antsRival){ ctx.beginPath(); ctx.arc(a.x,a.y,2,0,2*PI); ctx.fill(); }
  ctx.restore();
}

function refreshMats(){
  const row=document.getElementById('matRow'); row.innerHTML='';
  const sel=document.getElementById('craftSel').value;
  const need = (RECIPES[sel] && RECIPES[sel].cost) || {};
  for(const k of MATERIALS){
    const d=document.createElement('div'); d.className='mini mat'+(need[k]? ' hi':'');
    d.textContent=k+': '+(mats[k]||0)+' '+(need[k]?`(需${need[k]})`:'');
    row.appendChild(d);
  }
}
function refreshInv(){
  const list=document.getElementById('invList'); list.innerHTML='';
  for(const id of Object.keys(RECIPES)){
    const btn=document.createElement('button'); btn.textContent=RECIPES[id].label;
    btn.onclick=function(){ selectedPh=id; document.getElementById('craftSel').value=id; refreshMats(); };
    list.appendChild(btn);
    const b=document.createElement('span'); b.className='mini'; b.textContent=(inventory[id]||0); list.appendChild(b);
  }
}
function buildCraftSel(){
  const sel=document.getElementById('craftSel'); sel.innerHTML='';
  for(const id of Object.keys(RECIPES)){ const o=document.createElement('option'); o.value=id; o.textContent=RECIPES[id].label; sel.appendChild(o); }
  sel.value=selectedPh;
  sel.onchange = ()=>{ selectedPh = sel.value; refreshMats(); };
}

document.getElementById('btnCraft').onclick=function(){
  const id=document.getElementById('craftSel').value;
  const need=RECIPES[id].cost;
  for(const k in need){ if((mats[k]||0)<need[k]) return; }
  for(const k in need) mats[k]-=need[k];
  inventory[id]=(inventory[id]||0)+1;
  refreshInv(); refreshMats();
};

function countFoodFrags(){
  let frag=0, cells=0; for(let i=0;i<grid.length;i++){ const c=grid[i]; if(c.type===T_FOOD && c.food && Array.isArray(c.food.frags)){ frag+=c.food.frags.length; cells++; } }
  return {frag, cells};
}
function updateOverview(){
  document.getElementById('meAnts').textContent = ants.length;
  document.getElementById('rvAnts').textContent = antsRival.length;
  document.getElementById('meScore').textContent = scoreMe;
  document.getElementById('rvScore').textContent = scoreRival;
  const {frag, cells} = countFoodFrags();
  document.getElementById('fragCount').textContent = String(frag);
  document.getElementById('proteinMe').textContent = String(proteinMe);
  document.getElementById('proteinRv').textContent = String(proteinRv);
  const btn = document.getElementById('btnMoreFood'); btn.style.display = (cells===0)? 'inline-block':'none';
}

/*** dashboards (60×60) ***/
const cWx=document.getElementById('wxClock').getContext('2d');
const cHum=document.getElementById('humGauge').getContext('2d');
const cSpd=document.getElementById('spdClock').getContext('2d');
const cZoom=document.getElementById('zoomGauge').getContext('2d');
const speedSlider=document.getElementById('speedSlider');
let angSec=0, angMin=0, angHour=0;
function drawWxClock(){
  const w=60,h=60,o=cWx; o.setTransform(1,0,0,1,0,0); o.clearRect(0,0,w,h); o.translate(w/2,h/2);
  o.strokeStyle="#2b3246"; o.lineWidth=1.5; o.beginPath(); o.arc(0,0,26,0,2*PI); o.stroke();
  o.strokeStyle="#3a415a"; for(let i=0;i<12;i++){ const a=i*PI/6; o.beginPath(); o.moveTo(Math.cos(a)*22, Math.sin(a)*22); o.lineTo(Math.cos(a)*26, Math.sin(a)*26); o.stroke(); }
  const angIn = (wx.windDir + 180) * PI/180;
  o.fillStyle="#9aa4b2"; o.beginPath(); o.arc(Math.cos(angIn)*24, Math.sin(angIn)*24, 2.2, 0, 2*PI); o.fill();
  o.fillStyle="#cbd3e3"; o.font="bold 12px ui-sans-serif"; o.textAlign="center"; o.textBaseline="middle"; o.fillText(wx.wind.toFixed(1), 0, 0);
}
function drawHum(){
  const w=60,h=60,o=cHum; o.setTransform(1,0,0,1,0,0); o.clearRect(0,0,w,h); o.translate(w/2,h/2);
  const start=PI*7/6, end=PI*11/6;
  o.strokeStyle="#2b3246"; o.lineWidth=8; o.globalAlpha=0.35; o.beginPath(); o.arc(0,0,22,start,end); o.stroke();
  const t=Math.max(0,Math.min(1, (wx.humidIdx/9))); o.globalAlpha=0.75; o.strokeStyle="#6e7890"; o.beginPath(); o.arc(0,0,22,start, start + (end-start)*t); o.stroke(); o.globalAlpha=1;
  const perc = Math.round(t*100);
  o.fillStyle="#cbd3e3"; o.font="bold 12px ui-sans-serif"; o.textAlign="center"; o.textBaseline="middle"; o.fillText(perc+'%', 0, 0);
}
function drawSpd(){
  const w=60,h=60,o=cSpd; o.setTransform(1,0,0,1,0,0); o.clearRect(0,0,w,h); o.translate(w/2,h/2);
  o.strokeStyle="#2b3246"; o.lineWidth=1.5; o.beginPath(); o.arc(0,0,26,0,2*PI); o.stroke();
  if(timeScale>1) hasAccelerated=true;
  let base;
  if(hasAccelerated){ base = new Date(baseTaipei.getTime() + simElapsed*1000); }
  else { base = taipeiNowDate(); }
  angSec = (base.getSeconds()/60)*2*PI;
  angMin = ((base.getMinutes() + base.getSeconds()/60)/60)*2*PI;
  angHour = (((base.getHours()%12) + base.getMinutes()/60)/12)*2*PI;
  o.strokeStyle="#77e4a0"; o.lineWidth=3; o.beginPath(); o.moveTo(0,0); o.lineTo(Math.cos(angHour)*14, Math.sin(angHour)*14); o.stroke();
  o.strokeStyle="#ffd36e"; o.lineWidth=2; o.beginPath(); o.moveTo(0,0); o.lineTo(Math.cos(angMin)*20, Math.sin(angMin)*20); o.stroke();
  o.strokeStyle="#e8eefc"; o.lineWidth=1; o.beginPath(); o.moveTo(0,0); o.lineTo(Math.cos(angSec)*22, Math.sin(angSec)*22); o.stroke();
  cSpd.canvas.onclick = ()=>{ timeScale=1; speedSlider.value='1'; viewScale=1; viewX=0; viewY=0; hasAccelerated=false; simElapsed=0; baseTaipei=taipeiNowDate(); };
  const total = Math.floor(simElapsed);
  const dd = Math.floor(total/86400); const hh = Math.floor((total%86400)/3600); const mm = Math.floor((total%3600)/60); const ss = total%60;
  document.getElementById('accumTime').textContent = String(dd).padStart(2,'0')+':'+String(hh).padStart(2,'0')+':'+String(mm).padStart(2,'0')+':'+String(ss).padStart(2,'0');
}
function drawZoom(){
  const w=60,h=60,o=cZoom; o.setTransform(1,0,0,1,0,0); o.clearRect(0,0,w,h); o.translate(w/2,h/2);
  o.strokeStyle="#2b3246"; o.lineWidth=1.5; o.beginPath(); o.arc(0,0,26,0,2*PI); o.stroke();
  const k = clamp((viewScale-0.5)/(4-0.5), 0, 1); o.fillStyle="#9aa4b2"; o.globalAlpha=0.25+0.5*k; o.beginPath(); o.arc(0,0, 26*k + 4, 0, 2*PI); o.fill(); o.globalAlpha=1; 
  o.fillStyle="#cbd3e3"; o.font="bold 12px ui-sans-serif"; o.textAlign="center"; o.textBaseline="middle"; o.fillText("1:1",0,0);
  cZoom.canvas.onclick = ()=>{ viewScale=1; viewX=0; viewY=0; };
}
speedSlider.addEventListener('input', e=>{ timeScale=Number(e.target.value)||1; });

document.getElementById('btnRestart').onclick=function(){ resetGame(); };
document.getElementById('levelSel').onchange=function(e){ level=parseInt(e.target.value,10); resetGame(); };
document.getElementById('btnMoreFood').onclick=function(){
  scatterFood(['fish','peanut','cater','resin','citrus','oil','berry','wax','chitin'], Math.max(1, Math.floor(initialFoodCount/2)));
};

canvas.addEventListener('mousedown', function(e){
  if(e.button!==0) return;
  const rect=canvas.getBoundingClientRect(); const dpr=window.devicePixelRatio||1;
  const wxp = (e.clientX-rect.left)/dpr/viewScale + viewX; const wyp = (e.clientY-rect.top )/dpr/viewScale + viewY;
  const gx=Math.floor(wxp/TILE), gy=Math.floor(wyp/TILE);
  if(!inBounds(gx,gy)) return;
  const dir = Math.atan2(wyp - (gy*TILE+TILE/2), wxp - (gx*TILE+TILE/2));
  placePher(gx,gy, selectedPh, 1.0, 'me', Math.cos(dir), Math.sin(dir));
});

function openRef(){
  document.getElementById('refModal').style.display='grid';
  const phTB=document.querySelector('#refPhTable tbody'); phTB.innerHTML='';
  for(const r of REF){ const tr=document.createElement('tr');
    tr.innerHTML = `<td>${r.label}</td><td><code class="k">${r.id}</code></td><td>${r.cls}</td><td>${r.mw}</td><td><span style="display:inline-block;width:12px;height:12px;background:${r.color};border:1px solid #2b3246;border-radius:3px"></span></td><td>${r.note||''}</td>`; phTB.appendChild(tr); }
  const rcTB=document.querySelector('#refRecipeTable tbody'); rcTB.innerHTML='';
  for(const id in RECIPES){ const r=RECIPES[id]; const parts=[]; for(const k in r.cost){ parts.push(`${k}×${r.cost[k]}`); } const tr=document.createElement('tr'); tr.innerHTML = `<td>${r.label}</td><td>${parts.join('、')}</td>`; rcTB.appendChild(tr); }
  const fdTB=document.querySelector('#refFoodTable tbody'); fdTB.innerHTML='';
  for(const key in FOOD_BASE){ const f=FOOD_BASE[key]; const parts=[]; for(const k in f.base){ parts.push(`${k}×${f.base[k]}`); } const tr=document.createElement('tr'); tr.innerHTML = `<td>${f.label}</td><td>${f.art}</td><td>${parts.join('、')}</td>`; fdTB.appendChild(tr); }
}
document.getElementById('btnRef').onclick=openRef;
document.getElementById('refClose').onclick=function(){ document.getElementById('refModal').style.display='none'; };

function resetGame(){
  ants=[]; antsRival=[]; mats={}; inventory={}; scoreMe=0; scoreRival=0; proteinMe=0; proteinRv=0;
  hasAccelerated=false; simElapsed=0; baseTaipei=taipeiNowDate();
  baseRandomMap(); initialFoodCount = 22; scatterFood(['fish','peanut','cater','resin','citrus','oil','berry','wax','chitin'], initialFoodCount);
  for(let i=0;i<10;i++) ants.push(spawnAnt('me'));
  for(let i=0;i<10;i++) antsRival.push(spawnAnt('rv'));
  buildCraftSel(); refreshMats(); refreshInv(); resizeCanvas(); updateOverview();
}
let _last=performance.now();
function loop(now){ const dt=(now-_last)/1000; _last=now;
  // 累積時間：永遠累加 dt*timeScale（未加速時即「真實經過時間」的近似值）
  simElapsed += dt*timeScale;
  const sdt = dt*timeScale;
  try{
    stepWeather(sdt); stepPher(sdt);
    for(const a of ants) stepAnt(a,sdt); for(const a of antsRival) stepAnt(a,sdt);
    autoRecruit();
    draw(); updateOverview(); drawWxClock(); drawHum(); drawSpd(); drawZoom();
  }catch(err){ reportError(err); }
  requestAnimationFrame(loop);
}
(function(){ try{ resetGame(); requestAnimationFrame(loop); } catch(err){ reportError(err); } })();
</script>
</body>
</html>